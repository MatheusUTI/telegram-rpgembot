# main.py
import os
import json
import traceback
import hmac
import hashlib
import urllib.parse
import functions_framework
import firebase_admin
from firebase_admin import firestore
import google.generativeai as genai

# Importar nossos novos módulos e arquivos
from modules import data_loader, telegram_actions
from modules.game_logic import character_creator, adventure_handler
import prompts

# --- Funções de Logging ---
def log_info(message): print(f"INFO: [main] {message}")
def log_error(message, exc_info=False):
    print(f"ERROR: [main] {message}")
    if exc_info: traceback.print_exc()

# --- Classe de Configuração para passar dependências ---
class GameConfig:
    """Agrupa todas as configurações e dados carregados para passar para os handlers."""
    def __init__(self):
        log_info("Inicializando GameConfig...")
        # Carregar dados do jogo
        self.CLASSES_DATA, self.RACAS_DATA = data_loader.carregar_dados_jogo()
        
        # Configurar Tokens
        self.TELEGRAM_TOKEN = "8185946655:AAGfyNTARWgaRU5ddoFG9hHR-7kPqMCjzo0"
        self.GEMINI_API_KEY = "AIzaSyDIzFVMGmNp7yg8ovN8o0KHML5DT86b7ho"

        # Configurar Gemini
        genai.configure(api_key=self.GEMINI_API_KEY)
        self.model = genai.GenerativeModel('gemini-1.5-flash')
        
        # Carregar Prompts
        self.PROMPTS = {
            "arbitro": prompts.PROMPT_ARBITRO,
            "mestre_narrador": prompts.PROMPT_MESTRE_NARRADOR,
            "narrador_simples": prompts.PROMPT_NARRADOR_SIMPLES
        }
        log_info("GameConfig inicializado com sucesso.")

# --- INICIALIZAÇÃO GLOBAL ---
log_info("Iniciando inicialização global do main.py...")
if not firebase_admin._apps:
    firebase_admin.initialize_app()
db = firestore.client()
config = GameConfig() # Cria uma instância única da configuração
log_info("Inicialização global do main.py concluída.")


# ==============================================================================
# === CLOUD FUNCTION 1: O WEBHOOK DO BOT DO TELEGRAM                          ===
# ==============================================================================
@functions_framework.http
def rpg_bot_webhook(request):
    log_info("Webhook recebido.")
    update = request.get_json(silent=True)
    if not update:
        log_info("Request sem JSON payload. Retornando OK.")
        return "OK", 200

    chat_id_para_erro, user_id = None, None

    try:
        # Extrair dados comuns do update
        if 'callback_query' in update:
            is_callback = True
            data = update['callback_query']
            user_id = str(data['from']['id'])
            chat_id = data['message']['chat']['id']
            message_id = data['message']['message_id']
            callback_data = data['data']
            user_text = None
            telegram_actions.answer_callback_query(config.TELEGRAM_TOKEN, data['id'])
        elif 'message' in update and 'text' in update['message']:
            is_callback = False
            message = update['message']
            user_id = str(message['from']['id'])
            chat_id = message['chat']['id']
            user_text = message['text']
            message_id = None
            callback_data = None
        else:
            log_info("Update sem conteúdo relevante (callback ou mensagem de texto). Ignorando.")
            return "OK", 200

        chat_id_para_erro = chat_id
        
        player_ref = db.collection('jogadores').document(user_id)
        player_doc = player_ref.get()
        player_data = player_doc.to_dict() if player_doc.exists else {}
        estado_atual = player_data.get('estado_criacao')

        # Comandos de sistema que podem ser executados em qualquer estado, tratados pelos handlers
        if not is_callback:
            if user_text.lower() == '/start':
                 adventure_handler.handle_start_command(config, user_id, chat_id, player_doc)
                 return "OK", 200
            if user_text.lower() == '/criar_personagem':
                character_creator.handle_criar_personagem_command(config, user_id, chat_id, player_ref)
                return "OK", 200
            if user_text.lower() == '/ficha':
                adventure_handler.handle_ficha_command(config, user_id, chat_id, player_doc)
                return "OK", 200

        # --- ROTEAMENTO DA LÓGICA ---
        if estado_atual:
            log_info(f"Roteando para Character Creator para user_id {user_id}. Estado: {estado_atual}")
            if is_callback:
                character_creator.handle_creation_callback(config, user_id, chat_id, message_id, callback_data, player_ref, player_data)
            else:
                character_creator.handle_creation_message(config, user_id, chat_id, user_text, player_ref, player_data)
        else:
            log_info(f"Roteando para Adventure Handler para user_id {user_id}.")
            if is_callback:
                adventure_handler.handle_adventure_callback(config, user_id, chat_id, message_id, callback_data, player_ref, player_data)
            else:
                adventure_handler.handle_adventure_message(config, user_id, chat_id, user_text, player_ref, player_data)

    except Exception as e:
        log_error(f"Erro INESPERADO no roteador principal para user_id {user_id}: {e}", exc_info=True)
        if chat_id_para_erro:
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id_para_erro, f"Ocorreu um erro catastrófico. Os Deuses Antigos foram alertados. (Detalhe: {type(e).__name__})")
    
    log_info("Finalizando processamento do webhook.")
    return "OK", 200


# ==============================================================================
# === CLOUD FUNCTION 2: A API SEGURA PARA A FICHA DE PERSONAGEM              ===
# ==============================================================================
@functions_framework.http
def get_char_sheet(request):
    log_info("API get_char_sheet chamada.")
    headers = {'Access-Control-Allow-Origin': '*','Access-Control-Allow-Methods': 'POST, OPTIONS','Access-Control-Allow-Headers': 'Content-Type'}
    if request.method == 'OPTIONS': return ('', 204, headers)
    request_json = request.get_json(silent=True)
    if not request_json or 'initData' not in request_json:
        log_error("API get_char_sheet: initData não fornecido.")
        return ({'error': 'initData não fornecido.'}, 400, headers)
    init_data = request_json['initData']
    try:
        parsed_data = dict(urllib.parse.parse_qsl(init_data))
        hash_recebido = parsed_data.pop('hash', None)
        if not hash_recebido:
            log_error("API get_char_sheet: Hash de validação não encontrado.")
            raise ValueError("Hash de validação não encontrado.")
        
        chaves_ordenadas = sorted(parsed_data.keys())
        data_check_string = "\n".join(f"{key}={parsed_data[key]}" for key in chaves_ordenadas)
        secret_key = hmac.new("WebAppData".encode('utf-8'), config.TELEGRAM_TOKEN.encode('utf-8'), hashlib.sha256).digest()
        hash_calculado = hmac.new(secret_key, data_check_string.encode('utf-8'), hashlib.sha256).hexdigest()

        if not hmac.compare_digest(hash_calculado, hash_recebido):
            log_error(f"API get_char_sheet: Falha na validação de hash.")
            return ({'error': 'Falha na validação dos dados (hash inválido).'}, 403, headers)
        
        user_data_str = parsed_data.get('user')
        if not user_data_str: log_error("API get_char_sheet: Dados do usuário não encontrados."); return ({'error': 'Dados do usuário não encontrados.'}, 400, headers)
        
        user_data = json.loads(user_data_str)
        user_id = str(user_data.get('id'))
        if not user_id: log_error("API get_char_sheet: ID de usuário não encontrado."); return ({'error': 'ID de usuário não encontrado.'}, 400, headers)
        
        log_info(f"API get_char_sheet: Solicitação validada para user_id: {user_id}")
        player_ref = db.collection('jogadores').document(user_id)
        player_doc = player_ref.get()

        if player_doc.exists:
            ficha_data = player_doc.to_dict().get('ficha', {})
            log_info(f"API get_char_sheet: Ficha encontrada para user_id: {user_id}")
            return (json.dumps(ficha_data, ensure_ascii=False), 200, headers)
        else:
            log_info(f"API get_char_sheet: Ficha NÃO encontrada para user_id: {user_id}")
            return ({'error': 'Ficha não encontrada.'}, 404, headers)
            
    except Exception as e_api:
        log_error(f"API get_char_sheet Erro Geral: {e_api}", exc_info=True)
        return ({'error': f'Erro interno: {str(e_api)}'}, 500, headers)

        # prompts.py
        # Este arquivo armazena todas as strings de prompt longas usadas para interagir com o modelo de IA.
        
        PROMPT_ARBITRO = """Analise a seguinte ação de um jogador em um RPG: "{}". A ação pode ser resolvida com uma simples narração (como olhar ao redor, falar, ou andar) ou ela possui um risco inerente de falha que exige um teste de perícia/sorte/força (como atacar, escalar, persuadir, se esconder)? Responda APENAS com a palavra `SIM` se um teste for necessário, ou `NÃO` se não for."""
        
        PROMPT_MESTRE_NARRADOR = """Você é o Mestre de Jogo para um RPG de fantasia chamado 'As Terras de Aethel', um mundo onde a magia está desaparecendo e a tecnologia a vapor está surgindo. Use um tom levemente sombrio e misterioso.
        REGRAS DO SISTEMA 'LÓGICA & SORTE':
        1. O sistema usa um dado de 20 lados (d20). O resultado bruto do dado rolado pelo jogador será informado a você.
        2. Sua principal tarefa é ser o juiz lógico. Analise a Ficha do Personagem e a situação para aplicar modificadores lógicos (vantagens ou desvantagens) à rolagem. Você não precisa mostrar cálculos, apenas narre o resultado final de forma imersiva.
        3. VANTAGEM LÓGICA: Se um personagem está bem preparado para uma ação (ex: um Ladino furtivo tentando se esconder nas sombras), o resultado do dado é efetivamente melhor. Um resultado baixo pode se tornar um sucesso simples.
        4. DESVANTAGEM LÓGICA: Se um personagem está mal preparado (ex: um Guerreiro de armadura de metal tentando ser furtivo), o resultado do dado é efetivamente pior. Um resultado médio pode se tornar uma falha.
        5. GRAUS DE SUCESSO: Use o resultado final (dado + modificadores) para determinar o grau de sucesso: Falha Crítica, Falha Simples, Sucesso com Custo, Sucesso Simples, ou Sucesso Excepcional.
        
        INFORMAÇÕES PARA A NARRAÇÃO:
        - Ficha do Personagem: {}
        - Histórico da Conversa: {}
        - Ação Tentada: "{}"
        - Resultado do Dado (d20): {}
        
        Sua tarefa é retornar APENAS a narração do que acontece a seguir, de forma criativa e imersiva. Se o resultado do d20 for 0, significa que a ação não requer um teste de dados, mas sim uma narração do impacto ou resultado da ação descrita.
        Se o resultado indicar um acerto de ataque, a sua narração deve deixar claro que o golpe conectou para que o jogador saiba que deve rolar o dano.
        """
        
        PROMPT_NARRADOR_SIMPLES = """Você é o Mestre de Jogo para um RPG de fantasia chamado 'As Terras de Aethel'. A seguinte ação do jogador não requer um teste de dados. Apenas narre o resultado da ação de forma simples e direta, preparando para a próxima ação.
        - Ação do Jogador: "{}"
        - Ficha do Personagem: {}
        """


requirements.txt
        firebase-admin==6.9.0
        google-generativeai==0.8.5
        python-telegram-bot==22.1
        functions-framework==3.8.3
        requests==2.32.3


telegram_actions.py
# modules/telegram_actions.py
import requests
import json

# Funções de logging podem ser importadas de um módulo de logging central no futuro,
# mas por enquanto, uma simples função print é suficiente aqui.
def log_error(message):
    print(f"ERROR: [telegram_actions] {message}")

def send_telegram_message(token, chat_id, text, keyboard=None):
    """Envia uma mensagem de texto para um chat do Telegram."""
    url = f"https://api.telegram.org/bot{token}/sendMessage"
    payload = {"chat_id": chat_id, "text": text, "parse_mode": "Markdown"}
    if keyboard:
        payload['reply_markup'] = json.dumps(keyboard)
    
    try:
        response = requests.post(url, json=payload, timeout=10) # Adicionado timeout
        response.raise_for_status()  # Levanta um erro para respostas 4xx/5xx
        return response.json()
    except requests.exceptions.RequestException as e:
        log_error(f"Erro de rede ao enviar mensagem para {chat_id}: {e}")
        return None

def edit_telegram_message(token, chat_id, message_id, text, keyboard=None):
    """Edita uma mensagem de texto existente no Telegram."""
    url = f"https://api.telegram.org/bot{token}/editMessageText"
    payload = {"chat_id": chat_id, "message_id": message_id, "text": text, "parse_mode": "Markdown"}
    if keyboard:
        payload['reply_markup'] = json.dumps(keyboard)

    try:
        response = requests.post(url, json=payload, timeout=10)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        log_error(f"Erro de rede ao editar mensagem {message_id} para {chat_id}: {e}")
        return None

def answer_callback_query(token, callback_query_id):
    """Responde a uma callback query para remover o ícone de 'carregando' no cliente."""
    url = f"https://api.telegram.org/bot{token}/answerCallbackQuery"
    payload = {"callback_query_id": callback_query_id}
    
    try:
        requests.post(url, json=payload, timeout=5)
    except requests.exceptions.RequestException as e:
        log_error(f"Erro de rede ao responder callback query {callback_query_id}: {e}")


data_loader.py
# modules/data_loader.py
import json

def log_info(message):
    """Função de log simples para informações."""
    print(f"INFO: [data_loader] {message}")

def log_error(message):
    """Função de log simples para erros."""
    print(f"ERROR: [data_loader] {message}")

def carregar_dados_jogo():
    """
    Carrega os arquivos de dados principais do jogo (classes e raças).
    Levanta um erro se o arquivo crítico de classes não puder ser carregado.
    Retorna os dados como dois dicionários.
    """
    classes_data = {}
    racas_data = {}

    # Carregar classes.json (crítico para a execução)
    try:
        log_info("Carregando game_data/classes.json...")
        with open('game_data/classes.json', 'r', encoding='utf-8') as f:
            classes_data = json.load(f)
        log_info(f"{len(classes_data)} classes carregadas com sucesso.")
        if not isinstance(classes_data, dict) or not classes_data:
            log_error("O arquivo classes.json não é um dicionário válido ou está vazio.")
            raise ValueError("classes.json inválido")
    except FileNotFoundError:
        log_error("O arquivo 'game_data/classes.json' não foi encontrado. A aplicação não pode continuar.")
        raise
    except json.JSONDecodeError as e:
        log_error(f"Falha ao decodificar 'game_data/classes.json'. Verifique a sintaxe. Erro: {e}")
        raise
    except Exception as e:
        log_error(f"Erro inesperado ao carregar 'game_data/classes.json': {e}")
        raise

    # Carregar racas.json (opcional, o jogo pode continuar sem ele)
    try:
        log_info("Carregando game_data/racas.json...")
        with open('game_data/racas.json', 'r', encoding='utf-8') as f:
            racas_data = json.load(f)
        log_info(f"{len(racas_data)} raças carregadas com sucesso.")
        if not isinstance(racas_data, dict):
            log_info("O arquivo racas.json não é um dicionário válido. Será tratado como vazio.")
            racas_data = {}
    except FileNotFoundError:
        log_info("AVISO: O arquivo 'game_data/racas.json' não foi encontrado. A escolha de raça não estará disponível.")
        racas_data = {}
    except json.JSONDecodeError as e:
        log_info(f"AVISO: Falha ao decodificar 'game_data/racas.json'. Erro: {e}")
        racas_data = {}
    except Exception as e:
        log_info(f"AVISO: Erro inesperado ao carregar 'game_data/racas.json': {e}")
        racas_data = {}

    return classes_data, racas_data



utils.py
# modules/game_logic/utils.py
import random

# Constantes do Jogo
ATRIBUTOS_LISTA = ["FOR", "DES", "CON", "INT", "SAB", "CAR"]
ARRAY_PADRAO_ATRIBUTOS = sorted([15, 14, 13, 12, 10, 8], reverse=True)

# Funções de Cálculo de Personagem
def calcular_modificador(valor_atributo):
    """Calcula o modificador de um atributo D&D 5e."""
    return (valor_atributo - 10) // 2

def obter_nome_completo_atributo(attr_key_upper):
    """Retorna o nome completo de um atributo a partir de sua abreviação."""
    nomes_atributos = {
        "FOR": "Força", "DES": "Destreza", "CON": "Constituição",
        "INT": "Inteligência", "SAB": "Sabedoria", "CAR": "Carisma"
    }
    return nomes_atributos.get(attr_key_upper, attr_key_upper)

def calcular_ca_final_com_equipamento(ca_base_personagem, inventario, modificadores):
    """Calcula a CA final baseada no inventário (lógica simplificada)."""
    ca_final = ca_base_personagem
    tem_escudo = False
    armadura_principal_ca_valor = 0

    if not isinstance(modificadores, dict): modificadores = {}
    if not isinstance(inventario, list): inventario = []

    for item in inventario:
        if isinstance(item, dict):
            nome_item_lower = item.get('nome', '').lower()
            tipo_item = item.get('tipo', '')
            item_ca_base = item.get('ca_base', 0)

            if tipo_item == "armadura_pesada_ref" and item_ca_base > 0:
                armadura_principal_ca_valor = max(armadura_principal_ca_valor, item_ca_base)
                ca_final = armadura_principal_ca_valor
            elif tipo_item == "armadura_media_ref" and item_ca_base > 0:
                bonus_des = min(modificadores.get('des', 0), 2)
                armadura_principal_ca_valor = max(armadura_principal_ca_valor, item_ca_base + bonus_des)
                ca_final = armadura_principal_ca_valor
            elif tipo_item == "armadura_leve_ref" and item_ca_base > 0:
                bonus_des = modificadores.get('des', 0)
                armadura_principal_ca_valor = max(armadura_principal_ca_valor, item_ca_base + bonus_des)
                ca_final = armadura_principal_ca_valor
            
            if "escudo" in nome_item_lower or (item.get('ca_bonus', 0) > 0 and tipo_item == "armadura_aux"):
                tem_escudo = True
        elif isinstance(item, str) and "escudo" in item.lower():
            tem_escudo = True
            
    if armadura_principal_ca_valor == 0:  # Nenhuma armadura corporal principal, usa CA base que já inclui ModDES
        ca_final = ca_base_personagem
    
    if tem_escudo:
        ca_final += 2
        
    return ca_final

# Funções de Cálculo de Combate
def parse_dado_str(dado_str):
    """Parseia uma string como '1d8' para (numero_dados, tipo_dado)."""
    if not isinstance(dado_str, str) or 'd' not in dado_str: return 0, 0
    parts = dado_str.lower().split('d')
    try:
        num_dados = int(parts[0]) if parts[0] else 1
        tipo_dado = int(parts[1])
        return num_dados, tipo_dado
    except (ValueError, IndexError):
        return 0, 0

def rolar_dados_dano(dado_str, modificador_dano):
    """Rola dados (ex: '1d8') e adiciona modificador, retorna total e string da rolagem."""
    num_dados, tipo_dado = parse_dado_str(dado_str)
    if num_dados == 0:
        return 0, "Erro na formatação do dado"
    
    rolagens = []
    soma_rolagens = 0
    for _ in range(num_dados):
        roll = random.randint(1, tipo_dado)
        rolagens.append(roll)
        soma_rolagens += roll
    
    total_dano = soma_rolagens + modificador_dano
    rolagem_str_fmt = f"{soma_rolagens} ({'+'.join(map(str, rolagens))})"
    if modificador_dano != 0:
        rolagem_str_fmt += f" {'+' if modificador_dano >=0 else ''}{modificador_dano} [Mod]"
    return total_dano, rolagem_str_fmt


character_creator.py
# modules/game_logic/character_creator.py
from firebase_admin import firestore
from modules import telegram_actions
from modules.game_logic import utils # Importa o nosso novo módulo de utilidades

# ==============================================================================
# === FUNÇÕES AUXILIARES DE CRIAÇÃO (PRIVADAS A ESTE MÓDULO)                 ===
# ==============================================================================

def _apresentar_escolha_pericias(config, chat_id, message_id, classe_key, player_ref, ficha_em_criacao):
    """
    Apresenta as opções de perícias para o jogador.
    Se não houver escolhas, finaliza esta etapa e avança para o background.
    """
    classe_info = config.CLASSES_DATA.get(classe_key, {})
    nome_classe_exibido = classe_info.get('nome_exibido', 'Sua classe')
    num_escolhas_total = classe_info.get('pericias_escolha_num', 0)
    opcoes_pericias_classe = classe_info.get('pericias_opcoes', [])
    pericias_ja_proficientes = ficha_em_criacao.get('pericias_proficientes', [])
    opcoes_reais_para_escolha = [p for p in opcoes_pericias_classe if p not in pericias_ja_proficientes]

    if num_escolhas_total <= 0 or not opcoes_reais_para_escolha:
        player_ref.update({'estado_criacao': 'AGUARDANDO_BACKGROUND'})
        equipamento = classe_info.get('equipamento_inicial', [])
        inventario_atual = ficha_em_criacao.get('inventario', [])
        for eq_item in equipamento:
            nome_item_novo = eq_item.get("nome") if isinstance(eq_item, dict) else eq_item
            if not any((item_inv.get("nome") if isinstance(item_inv, dict) else item_inv) == nome_item_novo for item_inv in inventario_atual):
                inventario_atual.append(eq_item)

        ca_final = utils.calcular_ca_final_com_equipamento(
            ficha_em_criacao.get('ca_base', 10), inventario_atual, ficha_em_criacao.get('modificadores', {}))
        
        player_ref.update({
            'ficha_em_criacao.inventario': inventario_atual,
            'ficha_em_criacao.ca_final': ca_final,
            'ficha_em_criacao.pericias_escolhas_restantes': firestore.DELETE_FIELD,
            'ficha_em_criacao.pericias_opcoes_atuais': firestore.DELETE_FIELD
        })
        msg_final_pericias = f"Todas as perícias de *{nome_classe_exibido}* foram definidas.\nEquipamento inicial adicionado. Sua Classe de Armadura (CA) final é *{ca_final}*."
        if message_id: telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, msg_final_pericias)
        else: telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, msg_final_pericias)
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Interessante... Agora, vamos à sua história. O que você fazia antes de se tornar um aventureiro?")
        return

    player_ref.update({
        'ficha_em_criacao.pericias_escolhas_restantes': num_escolhas_total,
        'ficha_em_criacao.pericias_opcoes_atuais': opcoes_reais_para_escolha
    })
    
    # --- INÍCIO DA CORREÇÃO ---
    texto = f"Como *{nome_classe_exibido}*, você tem aptidão em diversas áreas. Escolha *{num_escolhas_total}* perícia(s) da lista abaixo para se especializar.\n\nEscolha sua primeira perícia:"
    
    # Criar uma lista simples de botões, cada um em sua própria linha.
    # Isso é mais seguro e evita erros de formatação com o Telegram.
    botoes_simples = []
    for pericia in opcoes_reais_para_escolha:
        botoes_simples.append(
            [{'text': pericia, 'callback_data': f'skill_choice:{pericia}'}]
        )

    reply_markup = {'inline_keyboard': botoes_simples}
    
    # A mensagem anterior (escolha de classe/habilidade) já foi editada para confirmar.
    # Esta sempre será uma NOVA mensagem com os botões de perícia.
    telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, texto, reply_markup)
    # --- FIM DA CORREÇÃO ---


def _apresentar_escolhas_iniciais_classe(config, chat_id, message_id, classe_escolhida, player_ref, ficha_em_criacao):
    habilidades_nivel_1 = [h for h in config.CLASSES_DATA[classe_escolhida].get('habilidades', []) if h['nivel'] == 1]
    nome_classe_exibido = config.CLASSES_DATA[classe_escolhida].get('nome_exibido', classe_escolhida)
    texto_base_escolha = f"Como um(a) *{nome_classe_exibido}*,"

    if classe_escolhida == 'clerigo':
        dominios = [h for h in habilidades_nivel_1 if "Domínio Divino:" in h['nome']]
        if dominios:
            texto = f"{texto_base_escolha} sua fé se manifesta através de um Domínio Divino. Qual você devotará?"
            botoes = [[{'text': f"Domínio: {d['nome'].split(': ')[-1].replace(' (Exemplo)','')}", 'callback_data': f"subchoice:dominio:{d['nome']}"}] for d in dominios]
            telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, texto, {'inline_keyboard': botoes}); return
    elif classe_escolhida == 'guerreiro':
        estilos = [h for h in habilidades_nivel_1 if "Estilo de Luta" in h['nome']]
        if estilos:
            texto = f"{texto_base_escolha} seu treinamento lhe concedeu maestria em uma técnica. Qual você aprimorou?"
            botoes = [[{'text': f"Estilo: {s['nome'].split(': ')[-1]}", 'callback_data': f"subchoice:estilo_luta:{s['nome']}"}] for s in estilos]
            telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, texto, {'inline_keyboard': botoes}); return
    
    habilidades_gerais_nv1 = [h for h in habilidades_nivel_1 if "Domínio Divino:" not in h['nome'] and ("Estilo de Luta" not in h['nome'] or classe_escolhida != 'guerreiro')]
    if habilidades_gerais_nv1 and len(habilidades_gerais_nv1) > 1 and classe_escolhida not in ['barbaro', 'bardo', 'mago', 'clerigo', 'guerreiro']:
        texto = f"{texto_base_escolha} você possui talentos únicos. Escolha UMA habilidade inicial para focar:"
        botoes = [[{'text': hab['nome'], 'callback_data': f"ability_choice:{hab['nome']}"}] for hab in habilidades_gerais_nv1[:4]]
        telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, texto, {'inline_keyboard': botoes}); return

    habilidades_finais_nv1 = ficha_em_criacao.get('habilidades_aprendidas', [])
    for hab in habilidades_gerais_nv1:
        if hab['nome'] not in habilidades_finais_nv1: habilidades_finais_nv1.append(hab['nome'])
    
    oficio = config.CLASSES_DATA.get(classe_escolhida, {}).get('oficio', 'Nenhum'); mods = ficha_em_criacao.get('modificadores', {}); c_info = config.CLASSES_DATA.get(classe_escolhida, {})
    pv_max = ficha_em_criacao.get('pv_maximos', 0); ca_base = ficha_em_criacao.get('ca_base', 10 + mods.get('des',0))
    if pv_max == 0:
        if 'dado_vida' in c_info and 'con' in mods:
            try: v_dv = int(c_info['dado_vida'].replace('d','')); pv_max = v_dv + mods['con']
            except: pv_max = 8 + mods.get('con', 0)
        else: pv_max = 8 + mods.get('con', 0)
    
    player_ref.update({
        'ficha_em_criacao.habilidades_aprendidas': list(set(habilidades_finais_nv1)), 'ficha_em_criacao.oficio': oficio, 'ficha_em_criacao.pv_maximos': pv_max, 
        'ficha_em_criacao.pv_atuais': pv_max, 'ficha_em_criacao.ca_base': ca_base, 'ficha_em_criacao.bonus_proficiencia': 2, 'estado_criacao': 'AGUARDANDO_ESCOLHA_PERICIAS'
    })
    ficha_att_doc = player_ref.get(); ficha_para_pericias = ficha_att_doc.to_dict().get('ficha_em_criacao',{})
    telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, f"Talentos de *{nome_classe_exibido}* definidos!\nPV: {pv_max}, CA Base (sem armadura): {ca_base}.")
    _apresentar_escolha_pericias(config, chat_id, None, classe_escolhida, player_ref, ficha_para_pericias)

# ==============================================================================
# === HANDLERS DE CRIAÇÃO (FUNÇÕES PÚBLICAS DO MÓDULO)                      ===
# ==============================================================================

def handle_criar_personagem_command(config, user_id, chat_id, player_ref):
    """Inicia ou reinicia o fluxo de criação de personagem."""
    player_ref.set({
        'estado_criacao': 'AGUARDANDO_NOME',
        'ficha_em_criacao': {'pericias_proficientes': [], 'inventario': []},
        'historico': []
    }, merge=False)
    telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Vamos forjar seu destino... Por qual nome você é conhecido?")

def handle_creation_message(config, user_id, chat_id, user_text, player_ref, player_data):
    """Trata as mensagens de texto durante a criação do personagem."""
    estado_atual = player_data.get('estado_criacao')
    
    if estado_atual == 'AGUARDANDO_NOME':
        player_ref.update({'estado_criacao': 'AGUARDANDO_RACA', 'ficha_em_criacao.nome': user_text})
        texto_raca = f"Excelente nome, *{user_text}*!\n\nCada povo em Aethel tem suas lendas e talentos. Qual é a sua origem? Escolha sua Raça:"
        if config.RACAS_DATA:
            botoes_r = [[{'text': r_data['nome_exibido'], 'callback_data': f'race_choice:{r_key}'}] for r_key, r_data in config.RACAS_DATA.items()]
            botoes_r.sort(key=lambda r: r[0]['text'])
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, texto_raca, {'inline_keyboard': botoes_r})
        else:
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "AVISO: Raças não carregadas. Pulando para atributos.")
            player_ref.update({'estado_criacao': 'AGUARDANDO_DISTRIBUICAO_ATRIBUTOS'})
            primeiro_val = utils.ARRAY_PADRAO_ATRIBUTOS[0]
            txt_dist = "Vamos distribuir seus Atributos usando os valores: 15, 14, 13, 12, 10, 8.\n"
            txt_dist += f"Começando pelo valor mais alto, *{primeiro_val}*. Em qual atributo você deseja aplicá-lo?"
            b_dist_buttons = []
            for attr_k_upper in utils.ATRIBUTOS_LISTA:
                b_dist_buttons.append({'text': f'{utils.obter_nome_completo_atributo(attr_k_upper)} ({attr_k_upper})', 'callback_data': f'distribute_attr:{primeiro_val}:{attr_k_upper}'})
            reply_markup_dist_fallback = {'inline_keyboard': [b_dist_buttons[i:i + 2] for i in range(0, len(b_dist_buttons), 2)]}
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, txt_dist, reply_markup_dist_fallback)

    elif estado_atual == 'AGUARDANDO_BACKGROUND':
        player_ref.update({'estado_criacao': 'AGUARDANDO_MOTIVACAO', 'ficha_em_criacao.background': user_text})
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Interessante... E toda jornada tem um começo. O que te jogou na estrada em busca de aventura?")
    
    elif estado_atual == 'AGUARDANDO_MOTIVACAO':
        player_ref.update({'estado_criacao': 'AGUARDANDO_FALHA', 'ficha_em_criacao.motivacao': user_text})
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Até os maiores heróis têm uma fraqueza que os assombra. Qual é a sua?")
        
    elif estado_atual == 'AGUARDANDO_FALHA':
        ficha_final_doc = player_ref.get()
        ficha_final = ficha_final_doc.to_dict().get('ficha_em_criacao', {})
        ficha_final['falha'] = user_text
        ficha_final.update({'nivel': 1, 'marcos': 0})
        
        if 'ca_final' not in ficha_final:
            ficha_final['ca_final'] = utils.calcular_ca_final_com_equipamento(
                ficha_final.get('ca_base', 10), ficha_final.get('inventario', []), ficha_final.get('modificadores', {}))
        
        if 'bonus_proficiencia' not in ficha_final: ficha_final['bonus_proficiencia'] = 2
        if 'recursos' not in ficha_final: ficha_final['recursos'] = {} 
        if 'magias' not in ficha_final: ficha_final['magias'] = {'conhecidas': [], 'preparadas': [], 'slots_n1_atuais': 0, 'slots_n1_max':0}
        
        player_ref.set({'ficha': ficha_final, 'historico': player_data.get('historico', [])}, merge=True)
        player_ref.update({'estado_criacao': firestore.DELETE_FIELD, 'ficha_em_criacao': firestore.DELETE_FIELD})
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Perfeito! Seu personagem está pronto!\n\nUse /start para iniciar sua jornada.")

def handle_creation_callback(config, user_id, chat_id, message_id, callback_data, player_ref, player_data):
    """Trata os cliques em botões durante a criação do personagem."""
    ficha_em_criacao = player_data.get('ficha_em_criacao', {})
    
    if callback_data.startswith('race_choice:'):
        raca_key = callback_data.split(':', 1)[1]
        if raca_key not in config.RACAS_DATA:
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Raça inválida."); return
        
        raca_info = config.RACAS_DATA[raca_key]
        ficha_em_criacao['raca'] = raca_key; ficha_em_criacao['nome_raca_exibido'] = raca_info['nome_exibido']
        ficha_em_criacao['tracos_raciais'] = raca_info.get('tracos_raciais', [])
        ficha_em_criacao['deslocamento'] = raca_info.get('deslocamento', 9)
        pericias_atuais = ficha_em_criacao.get('pericias_proficientes', [])
        if "Proficiência (Percepção)" in raca_info.get('tracos_raciais', []): pericias_atuais.append("Percepção")
        ficha_em_criacao['pericias_proficientes'] = list(set(pericias_atuais))
        player_ref.update({'ficha_em_criacao': ficha_em_criacao, 'estado_criacao': 'AGUARDANDO_DISTRIBUICAO_ATRIBUTOS'})
        
        telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, f"Você escolheu ser um(a) *{raca_info['nome_exibido']}*.")
        
        primeiro_valor = utils.ARRAY_PADRAO_ATRIBUTOS[0]
        texto = f"Excelente escolha! Ser um(a) *{raca_info['nome_exibido']}* lhe confere certas aptidões.\n\nAgora, defina seus Atributos Fundamentais (15, 14, 13, 12, 10, 8).\n\nComeçando pelo valor mais alto, *{primeiro_valor}*. Em qual atributo você deseja aplicá-lo?"
        botoes = []
        for attr_k in utils.ATRIBUTOS_LISTA: botoes.append({'text': f'{utils.obter_nome_completo_atributo(attr_k)} ({attr_k})', 'callback_data': f'distribute_attr:{primeiro_valor}:{attr_k}'})
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, texto, {'inline_keyboard': [botoes[i:i + 2] for i in range(0, len(botoes), 2)]})

    elif callback_data.startswith('distribute_attr:'):
        _, v_str, attr_key_upper = callback_data.split(':', 2); v_int = int(v_str)
        a_base = ficha_em_criacao.get('atributos_base', {}); v_pend = ficha_em_criacao.get('valores_atributos_pendentes', list(utils.ARRAY_PADRAO_ATRIBUTOS))
        
        if attr_key_upper.lower() in a_base: telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, f"Atributo {utils.obter_nome_completo_atributo(attr_key_upper)} já definido."); return
        if v_int not in v_pend: telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, f"Valor {v_int} não disponível."); return
        
        a_base[attr_key_upper.lower()] = v_int; v_pend.remove(v_int)
        player_ref.update({'ficha_em_criacao.atributos_base': a_base, 'ficha_em_criacao.valores_atributos_pendentes': v_pend})
        
        if not v_pend:
            a_finais = dict(a_base); r_key = ficha_em_criacao.get('raca')
            if r_key and r_key in config.RACAS_DATA:
                ajustes = config.RACAS_DATA[r_key].get('ajustes_atributo', {});
                for attr_k, bonus in ajustes.items(): a_finais[attr_k] = a_finais.get(attr_k, 0) + bonus
            mods = {attr: utils.calcular_modificador(val) for attr, val in a_finais.items()}
            player_ref.update({'estado_criacao': 'AGUARDANDO_CLASSE', 'ficha_em_criacao.atributos': a_finais, 'ficha_em_criacao.modificadores': mods})
            telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, f"Você atribuiu {v_int} para {utils.obter_nome_completo_atributo(attr_key_upper)}.\nAtributos base definidos. Bônus raciais aplicados!")
            
            # --- INÍCIO DA CORREÇÃO ---
            texto_resumo_atributos = "Perfeito! Seus Atributos Finais são:\n"
            resumo_linhas = []
            for attr_k_l, attr_v in a_finais.items():
                mod = mods.get(attr_k_l, 0)
                sinal_mod = '+' if mod >= 0 else ''
                resumo_linhas.append(f"{utils.obter_nome_completo_atributo(attr_k_l.upper())}: {attr_v} (Mod: {sinal_mod}{mod})")
            
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, texto_resumo_atributos + "\n".join(resumo_linhas))
            
            texto_escolha_classe = "\nAgora, escolha sua vocação, seu chamado para a aventura:"
            botoes_classes = [[{'text': c_d['nome_exibido'], 'callback_data': f'class_choice:{c_k}'}] for c_k, c_d in config.CLASSES_DATA.items()]
            botoes_classes.sort(key=lambda r: r[0]['text'])
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, texto_escolha_classe, {'inline_keyboard': botoes_classes})
            # --- FIM DA CORREÇÃO ---
        else:
            prox_v = v_pend[0]; attrs_d = [a_k for a_k in utils.ATRIBUTOS_LISTA if a_k.lower() not in a_base]
            texto_n = f"Você atribuiu {v_int} para {utils.obter_nome_completo_atributo(attr_key_upper)}.\n\nPróximo valor a distribuir: *{prox_v}*. Em qual atributo restante você o aplicará?"
            b_prox = [];
            for a_d_k in attrs_d: b_prox.append({'text': f'{utils.obter_nome_completo_atributo(a_d_k)} ({a_d_k})', 'callback_data': f'distribute_attr:{prox_v}:{a_d_k}'})
            telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, texto_n, {'inline_keyboard': [b_prox[i:i + 2] for i in range(0, len(b_prox), 2)]})

    elif callback_data.startswith('class_choice:'):
        c_key = callback_data.split(':', 1)[1]; c_info = config.CLASSES_DATA.get(c_key, {})
        p_fixas = c_info.get('pericias_fixas', []); p_atuais = ficha_em_criacao.get('pericias_proficientes', [])
        for p_f in p_fixas:
            if p_f not in p_atuais: p_atuais.append(p_f)
        player_ref.update({'estado_criacao': 'AGUARDANDO_HABILIDADE_INICIAL', 'ficha_em_criacao.classe': c_key, 'ficha_em_criacao.pericias_proficientes': list(set(p_atuais))})
        f_att_doc = player_ref.get(); f_para_habs = f_att_doc.to_dict().get('ficha_em_criacao', {})
        _apresentar_escolhas_iniciais_classe(config, chat_id, message_id, c_key, player_ref, f_para_habs)

    elif callback_data.startswith('subchoice:') or callback_data.startswith('ability_choice:'):
        parts = callback_data.split(':', 2)
        tipo_esc, subtipo_ou_hab, hab_final = parts[0], parts[1], parts[2] if tipo_esc == 'subchoice' else parts[1]
        classe_p = ficha_em_criacao.get('classe');
        if not classe_p: telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Erro: Classe não definida. Reinicie."); return
        habs_atuais = ficha_em_criacao.get('habilidades_aprendidas', []);
        if hab_final not in habs_atuais: habs_atuais.append(hab_final)
        habs_nv1 = [h for h in config.CLASSES_DATA.get(classe_p, {}).get('habilidades', []) if h['nivel'] == 1]
        for hab_p in habs_nv1:
            is_sub = "Domínio Divino:" in hab_p['nome'] or "Estilo de Luta" in hab_p['nome']
            if hab_p['nome'] != hab_final and not is_sub and hab_p['nome'] not in habs_atuais: habs_atuais.append(hab_p['nome'])
        player_ref.update({'ficha_em_criacao.habilidades_aprendidas': list(set(habs_atuais)), 'estado_criacao': 'AGUARDANDO_ESCOLHA_PERICIAS'})
        f_para_pericias_doc = player_ref.get(); f_para_pericias = f_para_pericias_doc.to_dict().get('ficha_em_criacao',{})
        _apresentar_escolha_pericias(config, chat_id, message_id, classe_p, player_ref, f_para_pericias)

    elif callback_data.startswith('skill_choice:'):
        p_esc = callback_data.split(':',1)[1]
        p_prof = ficha_em_criacao.get('pericias_proficientes', []); p_rest = ficha_em_criacao.get('pericias_escolhas_restantes', 0); p_opts = ficha_em_criacao.get('pericias_opcoes_atuais', [])
        
        if p_esc in p_prof: telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Já proficiente. Escolha outra."); return
        if p_esc not in p_opts: telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Opção inválida."); return
        
        p_prof.append(p_esc); p_rest -= 1;
        if p_esc in p_opts: p_opts.remove(p_esc)
        
        player_ref.update({
            'ficha_em_criacao.pericias_proficientes': list(set(p_prof)),
            'ficha_em_criacao.pericias_escolhas_restantes': p_rest,
            'ficha_em_criacao.pericias_opcoes_atuais': p_opts
        })
        
        if p_rest <= 0 or not p_opts:
            c_key = ficha_em_criacao.get('classe'); c_info = config.CLASSES_DATA.get(c_key,{})
            equipamento = c_info.get('equipamento_inicial', []); inv = ficha_em_criacao.get('inventario', [])
            for item_novo in equipamento:
                n_novo = item_novo.get("nome") if isinstance(item_novo, dict) else item_novo
                if not any((i.get("nome") if isinstance(i, dict) else i) == n_novo for i in inv): inv.append(item_novo)
            ca_final = utils.calcular_ca_final_com_equipamento(
                ficha_em_criacao.get('ca_base', 10), inv, ficha_em_criacao.get('modificadores',{}))
            
            player_ref.update({
                'estado_criacao': 'AGUARDANDO_BACKGROUND', 'ficha_em_criacao.inventario': inv, 'ficha_em_criacao.ca_final': ca_final,
                'ficha_em_criacao.pericias_escolhas_restantes': firestore.DELETE_FIELD, 'ficha_em_criacao.pericias_opcoes_atuais': firestore.DELETE_FIELD
            })
            telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, f"Perícia *{p_esc}* adicionada. Todas as perícias de classe foram escolhidas.")
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, f"Equipamento inicial adicionado. Sua CA Final é *{ca_final}*.\n\nAgora, vamos à sua história. O que você fazia?")
        else:
            texto = f"Perícia *{p_esc}* adicionada.\nEscolha mais {p_rest} perícia(s):"
            b_prox = [[{'text': p, 'callback_data': f'skill_choice:{p}'}] for p in p_opts]
            reply_markup = {'inline_keyboard': [b_prox[i:i + 3] for i in range(0, len(b_prox), 3)] if len(b_prox) > 3 else b_prox}
            telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, texto, reply_markup)


adventure_handler.py
# modules/game_logic/adventure_handler.py
import json
import random
import urllib.parse
from firebase_admin import firestore
from modules import telegram_actions
from modules.game_logic import utils

# ==============================================================================
# === HANDLERS DE COMANDOS DO MODO AVENTURA                                  ===
# ==============================================================================

def handle_start_command(config, user_id, chat_id, player_doc):
    """Lida com o comando /start."""
    if player_doc.exists and 'ficha' in player_doc.to_dict():
        nome_personagem = player_doc.to_dict().get('ficha', {}).get('nome', 'Aventureiro(a)')
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, f"Bem-vindo(a) de volta, {nome_personagem}! Sua aventura nas Terras de Aethel continua...")
    else:
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Sua lenda ainda não foi escrita. Use /criar_personagem para forjar seu destino.")

def handle_ficha_command(config, user_id, chat_id, player_doc):
    """Lida com o comando /ficha."""
    # Substitua pela sua URL do Firebase Hosting
    hosting_url = "https://meu-rpg-duna.web.app"
    if player_doc.exists and 'ficha' in player_doc.to_dict():
        teclado = {'inline_keyboard': [[{'text': '📜 Abrir Ficha de Personagem', 'web_app': {'url': hosting_url}}]]}
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Aqui está sua ficha de aventureiro. Clique no botão abaixo para abri-la.", teclado)
    else:
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Você precisa criar um personagem primeiro! Use o comando /criar_personagem.")

# ==============================================================================
# === HANDLERS DE AÇÕES DO MODO AVENTURA (MENSAGENS E CALLBACKS)             ===
# ==============================================================================

def handle_adventure_message(config, user_id, chat_id, user_text, player_ref, player_data):
    """Trata as mensagens de texto no modo aventura."""
    ficha = player_data.get('ficha', {})
    historico = player_data.get('historico', [])

    # Lógica para o comando /atacar
    if user_text.lower().startswith('/atacar'):
        arma_equipada = None
        for item in ficha.get('inventario', []):
            if isinstance(item, dict) and item.get('tipo', '') == 'arma_equipavel':
                arma_equipada = item
                break
        
        if not arma_equipada:
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Nenhuma arma equipável encontrada!")
            return

        nome_arma = arma_equipada.get('nome', 'arma')
        propriedades_arma = arma_equipada.get('propriedades_arma', [])
        atributo_padrao_arma = arma_equipada.get('atributo_padrao', 'for')
        modificadores = ficha.get('modificadores', {})
        
        attr_ataque = atributo_padrao_arma
        if "acuidade" in propriedades_arma and modificadores.get('des', -5) > modificadores.get('for', -5):
            attr_ataque = 'des'
        
        bonus_attr = modificadores.get(attr_ataque, 0)
        bonus_prof = ficha.get('bonus_proficiencia', 2)
        bonus_total = bonus_attr
        
        proficiencias_armas = config.CLASSES_DATA.get(ficha.get('classe'), {}).get('proficiencia_armas', [])
        tipo_arma_prof = arma_equipada.get("tipo_arma_prof", "simples")
        is_proficiente = tipo_arma_prof in proficiencias_armas

        if is_proficiente:
            bonus_total += bonus_prof

        alvo = user_text.split(' ', 1)[1] if len(user_text.split(' ', 1)) > 1 else "um oponente"
        alvo_enc = urllib.parse.quote_plus(alvo)
        arma_enc = urllib.parse.quote_plus(nome_arma)
        
        texto_info = f"Você empunha sua *{nome_arma}* e mira em *{alvo}*!\nSeu bônus para acertar é *+{bonus_total}* (Base {attr_ataque.upper()}: {bonus_attr}, Prof: +{bonus_prof if is_proficiente else 0})."
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, texto_info)
        
        teclado = {'inline_keyboard': [[{'text': f'⚔️ Tentar Acertar {alvo} (Rolar d20)', 'callback_data': f'ataque_rolar_d20:{alvo_enc}:{arma_enc}:{bonus_total}:{attr_ataque}'}]]}
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Faça sua rolagem de ataque!", teclado)
        return

    # Lógica para ações genéricas
    try:
        prompt_arbitro = config.PROMPTS['arbitro'].format(user_text)
        convo_arbitro = config.model.start_chat(history=[])
        response_arbitro_obj = convo_arbitro.send_message(prompt_arbitro)
        resposta_arbitro = response_arbitro_obj.text.strip().upper()
    except Exception as e_gemini_arb:
        print(f"ERROR: [adventure_handler] Erro ao chamar Gemini (Árbitro) para user_id {user_id}: {e_gemini_arb}")
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "O Oráculo do Destino (IA Árbitro) está momentaneamente confuso. Tente uma ação diferente.")
        return

    entrada_jogador_hist = {"role": "user", "parts": [user_text]}
    if resposta_arbitro == "SIM":
        texto_pergunta = "O destino é incerto. Teste sua sorte."
        teclado = {'inline_keyboard': [[{'text': '🎲 Rolar d20 (Ação Geral)', 'callback_data': 'roll_d20'}]]}
        sent_message = telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, texto_pergunta, teclado)
        if sent_message and sent_message.get('ok'):
            player_ref.update({'acao_pendente': user_text, 'id_mensagem_dado': sent_message['result']['message_id']})
    else: # "NÃO"
        try:
            prompt_simples_fmt = config.PROMPTS['narrador_simples'].format(user_text, json.dumps(ficha, ensure_ascii=False, default=str))
            convo_simples = config.model.start_chat(history=[{"role": msg["role"], "parts": msg["parts"]} for msg in historico])
            response_simples = convo_simples.send_message(prompt_simples_fmt)
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, response_simples.text)
            entrada_modelo_hist = {"role": "model", "parts": [response_simples.text]}
            player_ref.update({'historico': firestore.ArrayUnion([entrada_jogador_hist, entrada_modelo_hist])})
        except Exception as e_gemini_narr:
            print(f"ERROR: [adventure_handler] Erro ao chamar Gemini (Narrador Simples) para user_id {user_id}: {e_gemini_narr}")
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "O Mestre dos Contos tropeçou em suas palavras. Tente novamente.")

def handle_adventure_callback(config, user_id, chat_id, message_id, callback_data, player_ref, player_data):
    """Trata os cliques em botões no modo aventura."""
    ficha = player_data.get('ficha', {})
    historico = player_data.get('historico', [])

    if callback_data == 'roll_d20':
        acao_pendente = player_data.get('acao_pendente')
        if acao_pendente:
            resultado_d20 = random.randint(1, 20)
            telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, f"Você lança seu destino aos ventos... o resultado do dado é *{resultado_d20}*!")
            entrada_user_hist = {"role": "user", "parts": [acao_pendente]}
            hist_para_gemini = historico + [entrada_user_hist]
            prompt = config.PROMPTS['mestre_narrador'].format(json.dumps(ficha, ensure_ascii=False), json.dumps(hist_para_gemini, ensure_ascii=False), acao_pendente, resultado_d20)
            convo = config.model.start_chat(history=[{"role": m["role"], "parts": m["parts"]} for m in historico])
            response = convo.send_message(prompt)
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, response.text)
            entrada_model_hist = {"role": "model", "parts": [response.text]}
            player_ref.update({'acao_pendente': firestore.DELETE_FIELD, 'id_mensagem_dado': firestore.DELETE_FIELD, 'historico': firestore.ArrayUnion([entrada_user_hist, entrada_model_hist])})
    
    elif callback_data.startswith('ataque_rolar_d20:'):
        parts = callback_data.split(':', 4)
        alvo_enc, arma_enc, bonus_str, attr_atk = parts[1], parts[2], parts[3], parts[4]
        alvo = urllib.parse.unquote_plus(alvo_enc); arma = urllib.parse.unquote_plus(arma_enc); bonus = int(bonus_str)
        d20_puro = random.randint(1, 20); total_atk = d20_puro + bonus
        telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, f"Atacando {alvo} com {arma}...\nd20: *{d20_puro}* + Bônus (+{bonus}) = Total: *{total_atk}*")
        
        acao_atk = f"Ataca {alvo} com {arma} (rolagem d20:{d20_puro}, total ataque:{total_atk})."
        hist_user = {"role": "user", "parts": [acao_atk]}; hist_gemini = historico + [hist_user]
        prompt = config.PROMPTS['mestre_narrador'].format(json.dumps(ficha, ensure_ascii=False), json.dumps(hist_gemini, ensure_ascii=False), f"Atacar {alvo} com {arma}", d20_puro)
        
        convo = config.model.start_chat(history=[{"role": m["role"], "parts": m["parts"]} for m in historico])
        response = convo.send_message(prompt); nar_acerto = response.text
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, nar_acerto)
        hist_model = {"role": "model", "parts": [nar_acerto]}
        
        acerto_ok = any(p in nar_acerto.lower() for p in ["acerta", "atinge", "consegue ferir", "golpe certeiro", "impacta", "conecta"])
        if acerto_ok:
            arma_info = next((item for item in ficha.get('inventario', []) if isinstance(item, dict) and item.get('nome') == arma), None)
            if arma_info:
                dado_dano, tipo_dano = arma_info.get('dado_dano', '1d4'), arma_info.get('tipo_dano_arma', 'concussão')
                attr_dano = arma_info.get('atributo_padrao', attr_atk)
                if "acuidade" in arma_info.get('propriedades_arma', []) and ficha.get('modificadores',{}).get('des',-5) > ficha.get('modificadores',{}).get('for',-5): attr_dano = 'des'
                dado_dano_enc = urllib.parse.quote_plus(dado_dano)
                teclado = {'inline_keyboard': [[{'text': f'💥 Rolar Dano ({dado_dano}) com {arma}', 'callback_data': f'ataque_rolar_dano:{alvo_enc}:{arma_enc}:{attr_dano}:{dado_dano_enc}:{tipo_dano}'}]]}
                telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Seu golpe conectou! Determine o estrago:", teclado)
                player_ref.update({'historico': firestore.ArrayUnion([hist_user, hist_model])})
            else:
                telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, f"(Mestre: Não encontrei {arma} para dano.)")
                player_ref.update({'historico': firestore.ArrayUnion([hist_user, hist_model])})
        else:
            player_ref.update({'historico': firestore.ArrayUnion([hist_user, hist_model])})

    elif callback_data.startswith('ataque_rolar_dano:'):
        parts = callback_data.split(':', 5)
        alvo_enc, arma_enc, attr_dano, dado_dano_enc, tipo_dano = parts[1], parts[2], parts[3], parts[4], parts[5]
        alvo, arma, dado_dano_str = urllib.parse.unquote_plus(alvo_enc), urllib.parse.unquote_plus(arma_enc), urllib.parse.unquote_plus(dado_dano_enc)
        
        mods = ficha.get('modificadores', {}); mod_dano = mods.get(attr_dano, 0)
        dano_total, rol_str = utils.rolar_dados_dano(dado_dano_str, mod_dano)
        
        telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, 
            f"Dano com *{arma}* em *{alvo}*:\nDados: {dado_dano_str}\nRolagem: {rol_str}\nTotal: *{dano_total}* de dano *{tipo_dano}*!")
        
        acao_dano = f"Causa {dano_total} de dano {tipo_dano} em {alvo} com {arma}."
        hist_user_dano = {"role": "user", "parts": [acao_dano]}; hist_gemini_dano = historico + [hist_user_dano]
        prompt = config.PROMPTS['mestre_narrador'].format(json.dumps(ficha, ensure_ascii=False), json.dumps(hist_gemini_dano, ensure_ascii=False), acao_dano, 0)
        
        convo = config.model.start_chat(history=[{"role": m["role"], "parts": m["parts"]} for m in historico])
        response = convo.send_message(prompt)
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, response.text)
        hist_model_dano = {"role": "model", "parts": [response.text]}
        player_ref.update({'historico': firestore.ArrayUnion([hist_user_dano, hist_model_dano])})


racas.json
{
    "humano": {
      "nome_exibido": "Humano",
      "descricao": "Adaptáveis e ambiciosos, os humanos são a raça mais comum, conhecida por sua diversidade e tenacidade.",
      "ajustes_atributo": {
        "for": 1, "des": 1, "con": 1, "int": 1, "sab": 1, "car": 1
      },
      "deslocamento": 9,
      "tracos_raciais": ["Versátil", "Um Idioma Adicional (Abstrato)"]
    },
    "elfo": {
      "nome_exibido": "Elfo (Alto Elfo)",
      "descricao": "Graciosos e conectados à magia ancestral, os altos elfos valorizam o conhecimento e as artes arcanas.",
      "ajustes_atributo": { "des": 2, "int": 1 },
      "deslocamento": 9,
      "tracos_raciais": ["Visão no Escuro", "Herança Feérica", "Transe", "Proficiência (Percepção)", "Truque de Mago (Abstrato)"]
    },
    "anao": {
      "nome_exibido": "Anão (da Montanha)",
      "descricao": "Resistentes e habilidosos artesãos, os anões da montanha são conhecidos por sua força e lealdade.",
      "ajustes_atributo": { "for": 2, "con": 2 },
      "deslocamento": 7.5,
      "tracos_raciais": ["Visão no Escuro", "Resiliência Anã", "Treinamento de Combate Anão (Machados, Machadinhas, Martelos)", "Proficiência (Ferramentas de Ferreiro - Abstrato)"]
    },
    "halfling": {
      "nome_exibido": "Halfling (Pés Leves)",
      "descricao": "Alegres e curiosos, os halflings pés leves são conhecidos por sua sorte e habilidade de se misturar.",
      "ajustes_atributo": { "des": 2, "car": 1 },
      "deslocamento": 7.5,
      "tracos_raciais": ["Sortudo", "Bravura", "Agilidade Halfling", "Furtividade Natural"]
    }
  }

classes.json
{
    "guerreiro": {
      "nome_exibido": "Guerreiro",
      "descricao": "Mestre de armas e táticas, o guerreiro é a espinha dorsal de qualquer grupo de aventureiros.",
      "oficio": "Forja de Armas",
      "dado_vida": "d10",
      "pericias_fixas": [],
      "pericias_escolha_num": 2,
      "pericias_opcoes": ["Acrobacia", "Adestrar Animais", "Atletismo", "História", "Intimidação", "Intuição", "Percepção", "Sobrevivência"],
      "proficiencia_armas": ["simples", "marciais"],
      "equipamento_inicial": [
        { "nome": "Cota de Malha", "tipo": "armadura_pesada_ref", "ca_base": 16 },
        { "nome": "Espada Longa", "tipo": "arma_equipavel", "tipo_arma_prof": "marcial", "atributo_padrao": "for", "dado_dano": "1d8", "tipo_dano_arma": "cortante", "propriedades_arma": ["versátil (1d10)"]},
        { "nome": "Escudo", "tipo": "armadura_aux", "ca_bonus": 2 },
        { "nome": "Duas Machadinhas", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "for", "dado_dano": "1d6", "tipo_dano_arma": "cortante", "propriedades_arma": ["leve", "arremesso (6/18m)"], "quantidade": 2}
      ],
      "habilidades": [
        { "nome": "Estilo de Luta: Defesa", "nivel": 1, "descricao": "Enquanto estiver usando armadura, você ganha +1 de bônus na CA." },
        { "nome": "Estilo de Luta: Duelo", "nivel": 1, "descricao": "Quando empunha uma arma corpo-a-corpo em uma só mão e nenhuma outra, você ganha +2 de bônus nas rolagens de dano com essa arma." },
        { "nome": "Estilo de Luta: Arquearia", "nivel": 1, "descricao": "Você ganha +2 de bônus nas rolagens de ataque com armas de ataque à distância." },
        { "nome": "Estilo de Luta: Grandes Armas", "nivel": 1, "descricao": "Quando rolar 1 ou 2 num dado de dano de um ataque com arma corpo-a-corpo que esteja empunhando com as duas mãos, você pode rolar o dado novamente e deve usar a nova rolagem." },
        { "nome": "Retomar o Fôlego", "nivel": 1, "descricao": "No seu turno, você pode usar uma ação bônus para recuperar PV igual a 1d10 + seu nível de guerreiro. Você precisa terminar um descanso curto ou longo antes de usar esta característica novamente." },
        { "nome": "Surto de Ação", "nivel": 2, "descricao": "No seu turno, você pode realizar uma ação adicional. Uma vez que usar esta característica, você precisa terminar um descanso curto ou longo para usá-la novamente." },
        { "nome": "Arquétipo Marcial: Campeão", "nivel": 3, "descricao": "Seus ataques com armas têm uma margem de crítico de 19-20." },
        { "nome": "Arquétipo Marcial: Mestre de Batalha", "nivel": 3, "descricao": "Você aprende manobras que são abastecidas por dados de superioridade especiais." },
        { "nome": "Arquétipo Marcial: Cavaleiro Arcano", "nivel": 3, "descricao": "Você combina proeza marcial com magia." },
        { "nome": "Ataque Extra", "nivel": 5, "descricao": "Você pode atacar duas vezes, em vez de uma, sempre que usar a ação Atacar no seu turno." }
      ]
    },
    "mago": {
      "nome_exibido": "Mago",
      "descricao": "Um estudioso da trama da realidade, o mago manipula as energias arcanas.",
      "oficio": "Caligrafia Arcana",
      "dado_vida": "d6",
      "pericias_fixas": [],
      "pericias_escolha_num": 2,
      "pericias_opcoes": ["Arcanismo", "História", "Intuição", "Investigação", "Medicina", "Religião"],
      "proficiencia_armas": ["adagas", "dardos", "fundas", "cajados", "bestas leves"],
      "equipamento_inicial": [
        { "nome": "Cajado", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "for", "dado_dano": "1d6", "tipo_dano_arma": "concussão", "propriedades_arma": ["versátil (1d8)"] },
        { "nome": "Grimório", "tipo": "item_chave" },
        { "nome": "Bolsa de Componentes", "tipo": "item_chave_foco_arcano" }
      ],
      "habilidades": [
        { "nome": "Conjuração (Mago)", "nivel": 1, "descricao": "Você conhece truques e pode preparar magias do seu grimório." },
        { "nome": "Recuperação Arcana", "nivel": 1, "descricao": "Após um descanso curto, você pode recuperar alguns espaços de magia gastos." },
        { "nome": "Tradição Arcana: Escola de Abjuração", "nivel": 2, "descricao": "Foco em magias de proteção e banimento." },
        { "nome": "Tradição Arcana: Escola de Evocação", "nivel": 2, "descricao": "Foco em magias de dano elemental." },
        { "nome": "Tradição Arcana: Escola de Ilusão", "nivel": 2, "descricao": "Foco em enganar os sentidos." }
      ]
    },
    "ladino": {
      "nome_exibido": "Ladino",
      "descricao": "Mestre das sombras, das habilidades e das oportunidades.",
      "oficio": "Criação de Ferramentas/Venenos",
      "dado_vida": "d8",
      "pericias_fixas": [],
      "pericias_escolha_num": 4,
      "pericias_opcoes": ["Acrobacia", "Atletismo", "Atuação", "Enganação", "Furtividade", "Intimidação", "Intuição", "Investigação", "Percepção", "Persuasão", "Prestidigitação"],
      "proficiencia_armas": ["simples", "bestas de mão", "espadas longas", "rapieiras", "espadas curtas"],
      "equipamento_inicial": [
        { "nome": "Rapieira", "tipo": "arma_equipavel", "tipo_arma_prof": "marcial", "atributo_padrao": "des", "dado_dano": "1d8", "tipo_dano_arma": "perfurante", "propriedades_arma": ["acuidade"] },
        { "nome": "Adaga", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "des", "dado_dano": "1d4", "tipo_dano_arma": "perfurante", "propriedades_arma": ["acuidade", "leve", "arremesso (6/18m)"], "quantidade": 2 },
        { "nome": "Arco Curto", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "des", "dado_dano": "1d6", "tipo_dano_arma": "perfurante", "propriedades_arma": ["munição (24/96m)", "duas mãos"] },
        { "nome": "Aljava com 20 Flechas", "tipo": "municao" },
        { "nome": "Armadura de Couro", "tipo": "armadura_leve_ref", "ca_base": 11 },
        { "nome": "Ferramentas de Ladrão", "tipo": "ferramenta" }
      ],
      "habilidades": [
        { "nome": "Especialização", "nivel": 1, "descricao": "Escolha duas de suas proficiências em perícias. Seu bônus de proficiência é dobrado para qualquer teste de habilidade que você fizer com elas." },
        { "nome": "Ataque Furtivo", "nivel": 1, "descricao": "Uma vez por turno, pode causar dano extra (1d6 no nível 1) a uma criatura que você atinge com um ataque se tiver vantagem ou um aliado adjacente." },
        { "nome": "Gíria de Ladrão", "nivel": 1, "descricao": "Você conhece os códigos secretos, dialetos e sinais usados por ladrões." },
        { "nome": "Ação Ardilosa", "nivel": 2, "descricao": "Você pode usar uma ação bônus para Correr, Desengajar ou se Esconder." },
        { "nome": "Arquétipo Ladino: Assassino", "nivel": 3, "descricao": "Você é um mestre em emboscadas e ataques letais." },
        { "nome": "Arquétipo Ladino: Ladrão", "nivel": 3, "descricao": "Suas mãos são incrivelmente rápidas para usar objetos e desarmar armadilhas." },
        { "nome": "Arquétipo Ladino: Trapaceiro Arcano", "nivel": 3, "descricao": "Você incrementa suas habilidades ladinas com magia." }
      ]
    },
    "clerigo": {
      "nome_exibido": "Clérigo",
      "descricao": "Um canal da vontade de uma divindade, o clérigo é um farol de fé.",
      "oficio": "Alquimia Sagrada",
      "dado_vida": "d8",
      "pericias_fixas": [],
      "pericias_escolha_num": 2,
      "pericias_opcoes": ["História", "Intuição", "Medicina", "Persuasão", "Religião"],
      "proficiencia_armas": ["simples"],
      "equipamento_inicial": [
        { "nome": "Maça", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "for", "dado_dano": "1d6", "tipo_dano_arma": "concussão" },
        { "nome": "Armadura de Escamas", "tipo": "armadura_media_ref", "ca_base": 14 },
        { "nome": "Escudo", "tipo": "armadura_aux", "ca_bonus": 2 },
        { "nome": "Símbolo Sagrado", "tipo": "item_chave_foco_divino" }
      ],
      "habilidades": [
        { "nome": "Conjuração (Clérigo)", "nivel": 1, "descricao": "Você pode preparar e conjurar magias divinas." },
        { "nome": "Domínio Divino: Vida", "nivel": 1, "descricao": "Suas magias de cura são mais potentes. Você ganha proficiência com armadura pesada." },
        { "nome": "Domínio Divino: Luz", "nivel": 1, "descricao": "Você pode usar sua reação para impor desvantagem cegando um inimigo com luz divina." },
        { "nome": "Domínio Divino: Guerra", "nivel": 1, "descricao": "Você pode realizar um ataque extra como ação bônus. Ganha proficiência com armas marciais e armadura pesada." },
        { "nome": "Domínio Divino: Conhecimento", "nivel": 1, "descricao": "Você ganha proficiências e pode usar Canalizar Divindade para perícias." },
        { "nome": "Domínio Divino: Natureza", "nivel": 1, "descricao": "Você ganha perícias e pode encantar animais e plantas." },
        { "nome": "Domínio Divino: Tempestade", "nivel": 1, "descricao": "Você ganha proficiências e pode retaliar com dano de trovão." },
        { "nome": "Domínio Divino: Trapaça", "nivel": 1, "descricao": "Você pode criar ilusões e ter vantagem em furtividade." },
        { "nome": "Canalizar Divindade: Expulsar Mortos-Vivos", "nivel": 2, "descricao": "Você pode usar seu símbolo sagrado para repelir mortos-vivos." }
      ]
    },
    "barbaro": {
      "nome_exibido": "Bárbaro",
      "descricao": "Vindo das fronteiras selvagens, o bárbaro é uma força da natureza.",
      "oficio": "Curtume e Caça",
      "dado_vida": "d12",
      "pericias_fixas": [],
      "pericias_escolha_num": 2,
      "pericias_opcoes": ["Adestrar Animais", "Atletismo", "Intimidação", "Natureza", "Percepção", "Sobrevivência"],
      "proficiencia_armas": ["simples", "marciais"],
      "equipamento_inicial": [
        { "nome": "Machado Grande", "tipo": "arma_equipavel", "tipo_arma_prof": "marcial", "atributo_padrao": "for", "dado_dano": "1d12", "tipo_dano_arma": "cortante", "propriedades_arma": ["pesada", "duas mãos"] },
        { "nome": "Duas Machadinhas", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "for", "dado_dano": "1d6", "tipo_dano_arma": "cortante", "propriedades_arma": ["leve", "arremesso (6/18m)"], "quantidade": 2 },
        { "nome": "Quatro Azagaias", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "for", "dado_dano": "1d6", "tipo_dano_arma": "perfurante", "propriedades_arma": ["arremesso (9/36m)"], "quantidade": 4 }
      ],
      "habilidades": [
        { "nome": "Fúria", "nivel": 1, "descricao": "Em combate, você pode entrar em fúria, ganhando bônus em ataques de Força, dano e resistência a dano." },
        { "nome": "Defesa sem Armadura (Bárbaro)", "nivel": 1, "descricao": "Enquanto não estiver usando armadura, sua CA é 10 + seu modificador de Destreza + seu modificador de Constituição." },
        { "nome": "Ataque Descuidado", "nivel": 2, "descricao": "Você pode atacar com vantagem, mas os ataques contra você também terão vantagem." },
        { "nome": "Sentido de Perigo", "nivel": 2, "descricao": "Você tem vantagem em testes de Destreza contra efeitos que pode ver, como armadilhas e magias." },
        { "nome": "Caminho Primitivo: Caminho do Berserker", "nivel": 3, "descricao": "Sua fúria se torna um frenesi implacável." },
        { "nome": "Caminho Primitivo: Caminho do Guerreiro Totêmico", "nivel": 3, "descricao": "Você comunga com espíritos animais que concedem benefícios em fúria." }
      ]
    },
    "bardo": {
      "nome_exibido": "Bardo",
      "descricao": "Um mestre da música, da palavra e da magia.",
      "oficio": "Criação de Instrumentos Musicais",
      "dado_vida": "d8",
      "pericias_fixas": [],
      "pericias_escolha_num": 3,
      "pericias_opcoes": ["Acrobacia", "Adestrar Animais", "Arcanismo", "Atletismo", "Atuação", "Enganação", "Furtividade", "História", "Intimidação", "Intuição", "Investigação", "Medicina", "Natureza", "Percepção", "Persuasão", "Prestidigitação", "Religião", "Sobrevivência"],
      "proficiencia_armas": ["simples", "bestas de mão", "espadas longas", "rapieiras", "espadas curtas"],
      "equipamento_inicial": [
        { "nome": "Rapieira", "tipo": "arma_equipavel", "tipo_arma_prof": "marcial", "atributo_padrao": "des", "dado_dano": "1d8", "tipo_dano_arma": "perfurante", "propriedades_arma": ["acuidade"] },
        { "nome": "Adaga", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "des", "dado_dano": "1d4", "tipo_dano_arma": "perfurante", "propriedades_arma": ["acuidade", "leve", "arremesso (6/18m)"] },
        { "nome": "Alaúde", "tipo": "instrumento_musical_foco_arcano" },
        { "nome": "Armadura de Couro", "tipo": "armadura_leve_ref", "ca_base": 11 }
      ],
      "habilidades": [
        { "nome": "Conjuração (Bardo)", "nivel": 1, "descricao": "Você pode conjurar magias de bardo usando Carisma." },
        { "nome": "Inspiração de Bardo", "nivel": 1, "descricao": "Você pode usar uma ação bônus para inspirar um aliado, concedendo-lhe um dado de Inspiração (d6 no nível 1)." },
        { "nome": "Faz-Tudo (Jack of All Trades)", "nivel": 2, "descricao": "Você pode adicionar metade do seu bônus de proficiência a qualquer teste de habilidade que você não seja proficiente." },
        { "nome": "Canção de Descanso", "nivel": 2, "descricao": "Durante um descanso curto, você pode usar música para ajudar seus aliados a se recuperarem melhor." },
        { "nome": "Colégio de Bardo: Colégio do Conhecimento", "nivel": 3, "descricao": "Você é um repositório de sabedoria e pode usar sua Inspiração para atrapalhar inimigos." },
        { "nome": "Colégio de Bardo: Colégio da Bravura", "nivel": 3, "descricao": "Você inspira coragem no campo de batalha, ganhando proficiências marciais." },
        { "nome": "Especialização em Perícia (Bardo)", "nivel": 3, "descricao": "Escolha duas de suas proficiências em perícias. Seu bônus de proficiência é dobrado para elas." }
      ]
    },
    "patrulheiro": {
      "nome_exibido": "Patrulheiro",
      "descricao": "Um guerreiro das selvas e fronteiras, especialista em sobrevivência e combate.",
      "oficio": "Herborismo e Criação de Armadilhas",
      "dado_vida": "d10",
      "pericias_fixas": [],
      "pericias_escolha_num": 3,
      "pericias_opcoes": ["Adestrar Animais", "Atletismo", "Furtividade", "Intuição", "Investigação", "Natureza", "Percepção", "Sobrevivência"],
      "proficiencia_armas": ["simples", "marciais"],
      "equipamento_inicial": [
        { "nome": "Armadura de Escamas", "tipo": "armadura_media_ref", "ca_base": 14 },
        { "nome": "Duas Espadas Curtas", "tipo": "arma_equipavel", "tipo_arma_prof": "marcial", "atributo_padrao": "des", "dado_dano": "1d6", "tipo_dano_arma": "perfurante", "propriedades_arma": ["acuidade", "leve"], "quantidade": 2 },
        { "nome": "Arco Longo", "tipo": "arma_equipavel", "tipo_arma_prof": "marcial", "atributo_padrao": "des", "dado_dano": "1d8", "tipo_dano_arma": "perfurante", "propriedades_arma": ["munição (45/180m)", "pesada", "duas mãos"] },
        { "nome": "Aljava com 20 Flechas", "tipo": "municao" }
      ],
      "habilidades": [
        { "nome": "Inimigo Predileto", "nivel": 1, "descricao": "Escolha um tipo de criatura como seu inimigo predileto. Você tem vantagem em testes para rastreá-los e recordar informações sobre eles." },
        { "nome": "Explorador Natural", "nivel": 1, "descricao": "Escolha um tipo de terreno favorito. Você ganha benefícios enquanto nele." },
        { "nome": "Estilo de Luta (Patrulheiro): Arquearia", "nivel": 2, "descricao": "Você ganha +2 de bônus nas rolagens de ataque com armas de ataque à distância." },
        { "nome": "Estilo de Luta (Patrulheiro): Defesa", "nivel": 2, "descricao": "Enquanto estiver usando armadura, você ganha +1 de bônus na CA." },
        { "nome": "Estilo de Luta (Patrulheiro): Duelo", "nivel": 2, "descricao": "Quando empunha uma arma corpo-a-corpo em uma só mão e nenhuma outra, você ganha +2 de bônus nas rolagens de dano com essa arma." },
        { "nome": "Estilo de Luta (Patrulheiro): Combate com Duas Armas", "nivel": 2, "descricao": "Quando você usa duas armas, pode adicionar seu modificador de atributo ao dano do segundo ataque." },
        { "nome": "Conjuração (Patrulheiro)", "nivel": 2, "descricao": "Você aprende a usar a essência mágica da natureza para conjurar magias." },
        { "nome": "Arquétipo de Patrulheiro: Caçador", "nivel": 3, "descricao": "Você é um mestre em abater ameaças com táticas especializadas." },
        { "nome": "Arquétipo de Patrulheiro: Mestre das Bestas", "nivel": 3, "descricao": "Você forma um laço com um companheiro animal que luta ao seu lado." }
      ]
    }
  }

