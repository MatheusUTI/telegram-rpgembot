# main.py
import os
import json
import traceback
import hmac
import hashlib
import urllib.parse
import functions_framework
import firebase_admin
from firebase_admin import firestore
import google.generativeai as genai

# Importar nossos novos m√≥dulos e arquivos
from modules import data_loader, telegram_actions
from modules.game_logic import character_creator, adventure_handler
import prompts

# --- Fun√ß√µes de Logging ---
def log_info(message): print(f"INFO: [main] {message}")
def log_error(message, exc_info=False):
    print(f"ERROR: [main] {message}")
    if exc_info: traceback.print_exc()

# --- Classe de Configura√ß√£o para passar depend√™ncias ---
class GameConfig:
    """Agrupa todas as configura√ß√µes e dados carregados para passar para os handlers."""
    def __init__(self):
        log_info("Inicializando GameConfig...")
        # Carregar dados do jogo
        self.CLASSES_DATA, self.RACAS_DATA = data_loader.carregar_dados_jogo()
        
        # Configurar Tokens
        self.TELEGRAM_TOKEN = "8185946655:AAGfyNTARWgaRU5ddoFG9hHR-7kPqMCjzo0"
        self.GEMINI_API_KEY = "AIzaSyDIzFVMGmNp7yg8ovN8o0KHML5DT86b7ho"

        # Configurar Gemini
        genai.configure(api_key=self.GEMINI_API_KEY)
        self.model = genai.GenerativeModel('gemini-1.5-flash')
        
        # Carregar Prompts
        self.PROMPTS = {
            "arbitro": prompts.PROMPT_ARBITRO,
            "mestre_narrador": prompts.PROMPT_MESTRE_NARRADOR,
            "narrador_simples": prompts.PROMPT_NARRADOR_SIMPLES
        }
        log_info("GameConfig inicializado com sucesso.")

# --- INICIALIZA√á√ÉO GLOBAL ---
log_info("Iniciando inicializa√ß√£o global do main.py...")
if not firebase_admin._apps:
    firebase_admin.initialize_app()
db = firestore.client()
config = GameConfig() # Cria uma inst√¢ncia √∫nica da configura√ß√£o
log_info("Inicializa√ß√£o global do main.py conclu√≠da.")


# ==============================================================================
# === CLOUD FUNCTION 1: O WEBHOOK DO BOT DO TELEGRAM                          ===
# ==============================================================================
@functions_framework.http
def rpg_bot_webhook(request):
    log_info("Webhook recebido.")
    update = request.get_json(silent=True)
    if not update:
        log_info("Request sem JSON payload. Retornando OK.")
        return "OK", 200

    chat_id_para_erro, user_id = None, None

    try:
        # Extrair dados comuns do update
        if 'callback_query' in update:
            is_callback = True
            data = update['callback_query']
            user_id = str(data['from']['id'])
            chat_id = data['message']['chat']['id']
            message_id = data['message']['message_id']
            callback_data = data['data']
            user_text = None
            telegram_actions.answer_callback_query(config.TELEGRAM_TOKEN, data['id'])
        elif 'message' in update and 'text' in update['message']:
            is_callback = False
            message = update['message']
            user_id = str(message['from']['id'])
            chat_id = message['chat']['id']
            user_text = message['text']
            message_id = None
            callback_data = None
        else:
            log_info("Update sem conte√∫do relevante (callback ou mensagem de texto). Ignorando.")
            return "OK", 200

        chat_id_para_erro = chat_id
        
        player_ref = db.collection('jogadores').document(user_id)
        player_doc = player_ref.get()
        player_data = player_doc.to_dict() if player_doc.exists else {}
        estado_atual = player_data.get('estado_criacao')

        # Comandos de sistema que podem ser executados em qualquer estado, tratados pelos handlers
        if not is_callback:
            if user_text.lower() == '/start':
                 adventure_handler.handle_start_command(config, user_id, chat_id, player_doc)
                 return "OK", 200
            if user_text.lower() == '/criar_personagem':
                character_creator.handle_criar_personagem_command(config, user_id, chat_id, player_ref)
                return "OK", 200
            if user_text.lower() == '/ficha':
                adventure_handler.handle_ficha_command(config, user_id, chat_id, player_doc)
                return "OK", 200

        # --- ROTEAMENTO DA L√ìGICA ---
        if estado_atual:
            log_info(f"Roteando para Character Creator para user_id {user_id}. Estado: {estado_atual}")
            if is_callback:
                character_creator.handle_creation_callback(config, user_id, chat_id, message_id, callback_data, player_ref, player_data)
            else:
                character_creator.handle_creation_message(config, user_id, chat_id, user_text, player_ref, player_data)
        else:
            log_info(f"Roteando para Adventure Handler para user_id {user_id}.")
            if is_callback:
                adventure_handler.handle_adventure_callback(config, user_id, chat_id, message_id, callback_data, player_ref, player_data)
            else:
                adventure_handler.handle_adventure_message(config, user_id, chat_id, user_text, player_ref, player_data)

    except Exception as e:
        log_error(f"Erro INESPERADO no roteador principal para user_id {user_id}: {e}", exc_info=True)
        if chat_id_para_erro:
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id_para_erro, f"Ocorreu um erro catastr√≥fico. Os Deuses Antigos foram alertados. (Detalhe: {type(e).__name__})")
    
    log_info("Finalizando processamento do webhook.")
    return "OK", 200


# ==============================================================================
# === CLOUD FUNCTION 2: A API SEGURA PARA A FICHA DE PERSONAGEM              ===
# ==============================================================================
@functions_framework.http
def get_char_sheet(request):
    log_info("API get_char_sheet chamada.")
    headers = {'Access-Control-Allow-Origin': '*','Access-Control-Allow-Methods': 'POST, OPTIONS','Access-Control-Allow-Headers': 'Content-Type'}
    if request.method == 'OPTIONS': return ('', 204, headers)
    request_json = request.get_json(silent=True)
    if not request_json or 'initData' not in request_json:
        log_error("API get_char_sheet: initData n√£o fornecido.")
        return ({'error': 'initData n√£o fornecido.'}, 400, headers)
    init_data = request_json['initData']
    try:
        parsed_data = dict(urllib.parse.parse_qsl(init_data))
        hash_recebido = parsed_data.pop('hash', None)
        if not hash_recebido:
            log_error("API get_char_sheet: Hash de valida√ß√£o n√£o encontrado.")
            raise ValueError("Hash de valida√ß√£o n√£o encontrado.")
        
        chaves_ordenadas = sorted(parsed_data.keys())
        data_check_string = "\n".join(f"{key}={parsed_data[key]}" for key in chaves_ordenadas)
        secret_key = hmac.new("WebAppData".encode('utf-8'), config.TELEGRAM_TOKEN.encode('utf-8'), hashlib.sha256).digest()
        hash_calculado = hmac.new(secret_key, data_check_string.encode('utf-8'), hashlib.sha256).hexdigest()

        if not hmac.compare_digest(hash_calculado, hash_recebido):
            log_error(f"API get_char_sheet: Falha na valida√ß√£o de hash.")
            return ({'error': 'Falha na valida√ß√£o dos dados (hash inv√°lido).'}, 403, headers)
        
        user_data_str = parsed_data.get('user')
        if not user_data_str: log_error("API get_char_sheet: Dados do usu√°rio n√£o encontrados."); return ({'error': 'Dados do usu√°rio n√£o encontrados.'}, 400, headers)
        
        user_data = json.loads(user_data_str)
        user_id = str(user_data.get('id'))
        if not user_id: log_error("API get_char_sheet: ID de usu√°rio n√£o encontrado."); return ({'error': 'ID de usu√°rio n√£o encontrado.'}, 400, headers)
        
        log_info(f"API get_char_sheet: Solicita√ß√£o validada para user_id: {user_id}")
        player_ref = db.collection('jogadores').document(user_id)
        player_doc = player_ref.get()

        if player_doc.exists:
            ficha_data = player_doc.to_dict().get('ficha', {})
            log_info(f"API get_char_sheet: Ficha encontrada para user_id: {user_id}")
            return (json.dumps(ficha_data, ensure_ascii=False), 200, headers)
        else:
            log_info(f"API get_char_sheet: Ficha N√ÉO encontrada para user_id: {user_id}")
            return ({'error': 'Ficha n√£o encontrada.'}, 404, headers)
            
    except Exception as e_api:
        log_error(f"API get_char_sheet Erro Geral: {e_api}", exc_info=True)
        return ({'error': f'Erro interno: {str(e_api)}'}, 500, headers)

        # prompts.py
        # Este arquivo armazena todas as strings de prompt longas usadas para interagir com o modelo de IA.
        
        PROMPT_ARBITRO = """Analise a seguinte a√ß√£o de um jogador em um RPG: "{}". A a√ß√£o pode ser resolvida com uma simples narra√ß√£o (como olhar ao redor, falar, ou andar) ou ela possui um risco inerente de falha que exige um teste de per√≠cia/sorte/for√ßa (como atacar, escalar, persuadir, se esconder)? Responda APENAS com a palavra `SIM` se um teste for necess√°rio, ou `N√ÉO` se n√£o for."""
        
        PROMPT_MESTRE_NARRADOR = """Voc√™ √© o Mestre de Jogo para um RPG de fantasia chamado 'As Terras de Aethel', um mundo onde a magia est√° desaparecendo e a tecnologia a vapor est√° surgindo. Use um tom levemente sombrio e misterioso.
        REGRAS DO SISTEMA 'L√ìGICA & SORTE':
        1. O sistema usa um dado de 20 lados (d20). O resultado bruto do dado rolado pelo jogador ser√° informado a voc√™.
        2. Sua principal tarefa √© ser o juiz l√≥gico. Analise a Ficha do Personagem e a situa√ß√£o para aplicar modificadores l√≥gicos (vantagens ou desvantagens) √† rolagem. Voc√™ n√£o precisa mostrar c√°lculos, apenas narre o resultado final de forma imersiva.
        3. VANTAGEM L√ìGICA: Se um personagem est√° bem preparado para uma a√ß√£o (ex: um Ladino furtivo tentando se esconder nas sombras), o resultado do dado √© efetivamente melhor. Um resultado baixo pode se tornar um sucesso simples.
        4. DESVANTAGEM L√ìGICA: Se um personagem est√° mal preparado (ex: um Guerreiro de armadura de metal tentando ser furtivo), o resultado do dado √© efetivamente pior. Um resultado m√©dio pode se tornar uma falha.
        5. GRAUS DE SUCESSO: Use o resultado final (dado + modificadores) para determinar o grau de sucesso: Falha Cr√≠tica, Falha Simples, Sucesso com Custo, Sucesso Simples, ou Sucesso Excepcional.
        
        INFORMA√á√ïES PARA A NARRA√á√ÉO:
        - Ficha do Personagem: {}
        - Hist√≥rico da Conversa: {}
        - A√ß√£o Tentada: "{}"
        - Resultado do Dado (d20): {}
        
        Sua tarefa √© retornar APENAS a narra√ß√£o do que acontece a seguir, de forma criativa e imersiva. Se o resultado do d20 for 0, significa que a a√ß√£o n√£o requer um teste de dados, mas sim uma narra√ß√£o do impacto ou resultado da a√ß√£o descrita.
        Se o resultado indicar um acerto de ataque, a sua narra√ß√£o deve deixar claro que o golpe conectou para que o jogador saiba que deve rolar o dano.
        """
        
        PROMPT_NARRADOR_SIMPLES = """Voc√™ √© o Mestre de Jogo para um RPG de fantasia chamado 'As Terras de Aethel'. A seguinte a√ß√£o do jogador n√£o requer um teste de dados. Apenas narre o resultado da a√ß√£o de forma simples e direta, preparando para a pr√≥xima a√ß√£o.
        - A√ß√£o do Jogador: "{}"
        - Ficha do Personagem: {}
        """


requirements.txt
        firebase-admin==6.9.0
        google-generativeai==0.8.5
        python-telegram-bot==22.1
        functions-framework==3.8.3
        requests==2.32.3


telegram_actions.py
# modules/telegram_actions.py
import requests
import json

# Fun√ß√µes de logging podem ser importadas de um m√≥dulo de logging central no futuro,
# mas por enquanto, uma simples fun√ß√£o print √© suficiente aqui.
def log_error(message):
    print(f"ERROR: [telegram_actions] {message}")

def send_telegram_message(token, chat_id, text, keyboard=None):
    """Envia uma mensagem de texto para um chat do Telegram."""
    url = f"https://api.telegram.org/bot{token}/sendMessage"
    payload = {"chat_id": chat_id, "text": text, "parse_mode": "Markdown"}
    if keyboard:
        payload['reply_markup'] = json.dumps(keyboard)
    
    try:
        response = requests.post(url, json=payload, timeout=10) # Adicionado timeout
        response.raise_for_status()  # Levanta um erro para respostas 4xx/5xx
        return response.json()
    except requests.exceptions.RequestException as e:
        log_error(f"Erro de rede ao enviar mensagem para {chat_id}: {e}")
        return None

def edit_telegram_message(token, chat_id, message_id, text, keyboard=None):
    """Edita uma mensagem de texto existente no Telegram."""
    url = f"https://api.telegram.org/bot{token}/editMessageText"
    payload = {"chat_id": chat_id, "message_id": message_id, "text": text, "parse_mode": "Markdown"}
    if keyboard:
        payload['reply_markup'] = json.dumps(keyboard)

    try:
        response = requests.post(url, json=payload, timeout=10)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        log_error(f"Erro de rede ao editar mensagem {message_id} para {chat_id}: {e}")
        return None

def answer_callback_query(token, callback_query_id):
    """Responde a uma callback query para remover o √≠cone de 'carregando' no cliente."""
    url = f"https://api.telegram.org/bot{token}/answerCallbackQuery"
    payload = {"callback_query_id": callback_query_id}
    
    try:
        requests.post(url, json=payload, timeout=5)
    except requests.exceptions.RequestException as e:
        log_error(f"Erro de rede ao responder callback query {callback_query_id}: {e}")


data_loader.py
# modules/data_loader.py
import json

def log_info(message):
    """Fun√ß√£o de log simples para informa√ß√µes."""
    print(f"INFO: [data_loader] {message}")

def log_error(message):
    """Fun√ß√£o de log simples para erros."""
    print(f"ERROR: [data_loader] {message}")

def carregar_dados_jogo():
    """
    Carrega os arquivos de dados principais do jogo (classes e ra√ßas).
    Levanta um erro se o arquivo cr√≠tico de classes n√£o puder ser carregado.
    Retorna os dados como dois dicion√°rios.
    """
    classes_data = {}
    racas_data = {}

    # Carregar classes.json (cr√≠tico para a execu√ß√£o)
    try:
        log_info("Carregando game_data/classes.json...")
        with open('game_data/classes.json', 'r', encoding='utf-8') as f:
            classes_data = json.load(f)
        log_info(f"{len(classes_data)} classes carregadas com sucesso.")
        if not isinstance(classes_data, dict) or not classes_data:
            log_error("O arquivo classes.json n√£o √© um dicion√°rio v√°lido ou est√° vazio.")
            raise ValueError("classes.json inv√°lido")
    except FileNotFoundError:
        log_error("O arquivo 'game_data/classes.json' n√£o foi encontrado. A aplica√ß√£o n√£o pode continuar.")
        raise
    except json.JSONDecodeError as e:
        log_error(f"Falha ao decodificar 'game_data/classes.json'. Verifique a sintaxe. Erro: {e}")
        raise
    except Exception as e:
        log_error(f"Erro inesperado ao carregar 'game_data/classes.json': {e}")
        raise

    # Carregar racas.json (opcional, o jogo pode continuar sem ele)
    try:
        log_info("Carregando game_data/racas.json...")
        with open('game_data/racas.json', 'r', encoding='utf-8') as f:
            racas_data = json.load(f)
        log_info(f"{len(racas_data)} ra√ßas carregadas com sucesso.")
        if not isinstance(racas_data, dict):
            log_info("O arquivo racas.json n√£o √© um dicion√°rio v√°lido. Ser√° tratado como vazio.")
            racas_data = {}
    except FileNotFoundError:
        log_info("AVISO: O arquivo 'game_data/racas.json' n√£o foi encontrado. A escolha de ra√ßa n√£o estar√° dispon√≠vel.")
        racas_data = {}
    except json.JSONDecodeError as e:
        log_info(f"AVISO: Falha ao decodificar 'game_data/racas.json'. Erro: {e}")
        racas_data = {}
    except Exception as e:
        log_info(f"AVISO: Erro inesperado ao carregar 'game_data/racas.json': {e}")
        racas_data = {}

    return classes_data, racas_data



utils.py
# modules/game_logic/utils.py
import random

# Constantes do Jogo
ATRIBUTOS_LISTA = ["FOR", "DES", "CON", "INT", "SAB", "CAR"]
ARRAY_PADRAO_ATRIBUTOS = sorted([15, 14, 13, 12, 10, 8], reverse=True)

# Fun√ß√µes de C√°lculo de Personagem
def calcular_modificador(valor_atributo):
    """Calcula o modificador de um atributo D&D 5e."""
    return (valor_atributo - 10) // 2

def obter_nome_completo_atributo(attr_key_upper):
    """Retorna o nome completo de um atributo a partir de sua abrevia√ß√£o."""
    nomes_atributos = {
        "FOR": "For√ßa", "DES": "Destreza", "CON": "Constitui√ß√£o",
        "INT": "Intelig√™ncia", "SAB": "Sabedoria", "CAR": "Carisma"
    }
    return nomes_atributos.get(attr_key_upper, attr_key_upper)

def calcular_ca_final_com_equipamento(ca_base_personagem, inventario, modificadores):
    """Calcula a CA final baseada no invent√°rio (l√≥gica simplificada)."""
    ca_final = ca_base_personagem
    tem_escudo = False
    armadura_principal_ca_valor = 0

    if not isinstance(modificadores, dict): modificadores = {}
    if not isinstance(inventario, list): inventario = []

    for item in inventario:
        if isinstance(item, dict):
            nome_item_lower = item.get('nome', '').lower()
            tipo_item = item.get('tipo', '')
            item_ca_base = item.get('ca_base', 0)

            if tipo_item == "armadura_pesada_ref" and item_ca_base > 0:
                armadura_principal_ca_valor = max(armadura_principal_ca_valor, item_ca_base)
                ca_final = armadura_principal_ca_valor
            elif tipo_item == "armadura_media_ref" and item_ca_base > 0:
                bonus_des = min(modificadores.get('des', 0), 2)
                armadura_principal_ca_valor = max(armadura_principal_ca_valor, item_ca_base + bonus_des)
                ca_final = armadura_principal_ca_valor
            elif tipo_item == "armadura_leve_ref" and item_ca_base > 0:
                bonus_des = modificadores.get('des', 0)
                armadura_principal_ca_valor = max(armadura_principal_ca_valor, item_ca_base + bonus_des)
                ca_final = armadura_principal_ca_valor
            
            if "escudo" in nome_item_lower or (item.get('ca_bonus', 0) > 0 and tipo_item == "armadura_aux"):
                tem_escudo = True
        elif isinstance(item, str) and "escudo" in item.lower():
            tem_escudo = True
            
    if armadura_principal_ca_valor == 0:  # Nenhuma armadura corporal principal, usa CA base que j√° inclui ModDES
        ca_final = ca_base_personagem
    
    if tem_escudo:
        ca_final += 2
        
    return ca_final

# Fun√ß√µes de C√°lculo de Combate
def parse_dado_str(dado_str):
    """Parseia uma string como '1d8' para (numero_dados, tipo_dado)."""
    if not isinstance(dado_str, str) or 'd' not in dado_str: return 0, 0
    parts = dado_str.lower().split('d')
    try:
        num_dados = int(parts[0]) if parts[0] else 1
        tipo_dado = int(parts[1])
        return num_dados, tipo_dado
    except (ValueError, IndexError):
        return 0, 0

def rolar_dados_dano(dado_str, modificador_dano):
    """Rola dados (ex: '1d8') e adiciona modificador, retorna total e string da rolagem."""
    num_dados, tipo_dado = parse_dado_str(dado_str)
    if num_dados == 0:
        return 0, "Erro na formata√ß√£o do dado"
    
    rolagens = []
    soma_rolagens = 0
    for _ in range(num_dados):
        roll = random.randint(1, tipo_dado)
        rolagens.append(roll)
        soma_rolagens += roll
    
    total_dano = soma_rolagens + modificador_dano
    rolagem_str_fmt = f"{soma_rolagens} ({'+'.join(map(str, rolagens))})"
    if modificador_dano != 0:
        rolagem_str_fmt += f" {'+' if modificador_dano >=0 else ''}{modificador_dano} [Mod]"
    return total_dano, rolagem_str_fmt


character_creator.py
# modules/game_logic/character_creator.py
from firebase_admin import firestore
from modules import telegram_actions
from modules.game_logic import utils # Importa o nosso novo m√≥dulo de utilidades

# ==============================================================================
# === FUN√á√ïES AUXILIARES DE CRIA√á√ÉO (PRIVADAS A ESTE M√ìDULO)                 ===
# ==============================================================================

def _apresentar_escolha_pericias(config, chat_id, message_id, classe_key, player_ref, ficha_em_criacao):
    """
    Apresenta as op√ß√µes de per√≠cias para o jogador.
    Se n√£o houver escolhas, finaliza esta etapa e avan√ßa para o background.
    """
    classe_info = config.CLASSES_DATA.get(classe_key, {})
    nome_classe_exibido = classe_info.get('nome_exibido', 'Sua classe')
    num_escolhas_total = classe_info.get('pericias_escolha_num', 0)
    opcoes_pericias_classe = classe_info.get('pericias_opcoes', [])
    pericias_ja_proficientes = ficha_em_criacao.get('pericias_proficientes', [])
    opcoes_reais_para_escolha = [p for p in opcoes_pericias_classe if p not in pericias_ja_proficientes]

    if num_escolhas_total <= 0 or not opcoes_reais_para_escolha:
        player_ref.update({'estado_criacao': 'AGUARDANDO_BACKGROUND'})
        equipamento = classe_info.get('equipamento_inicial', [])
        inventario_atual = ficha_em_criacao.get('inventario', [])
        for eq_item in equipamento:
            nome_item_novo = eq_item.get("nome") if isinstance(eq_item, dict) else eq_item
            if not any((item_inv.get("nome") if isinstance(item_inv, dict) else item_inv) == nome_item_novo for item_inv in inventario_atual):
                inventario_atual.append(eq_item)

        ca_final = utils.calcular_ca_final_com_equipamento(
            ficha_em_criacao.get('ca_base', 10), inventario_atual, ficha_em_criacao.get('modificadores', {}))
        
        player_ref.update({
            'ficha_em_criacao.inventario': inventario_atual,
            'ficha_em_criacao.ca_final': ca_final,
            'ficha_em_criacao.pericias_escolhas_restantes': firestore.DELETE_FIELD,
            'ficha_em_criacao.pericias_opcoes_atuais': firestore.DELETE_FIELD
        })
        msg_final_pericias = f"Todas as per√≠cias de *{nome_classe_exibido}* foram definidas.\nEquipamento inicial adicionado. Sua Classe de Armadura (CA) final √© *{ca_final}*."
        if message_id: telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, msg_final_pericias)
        else: telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, msg_final_pericias)
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Interessante... Agora, vamos √† sua hist√≥ria. O que voc√™ fazia antes de se tornar um aventureiro?")
        return

    player_ref.update({
        'ficha_em_criacao.pericias_escolhas_restantes': num_escolhas_total,
        'ficha_em_criacao.pericias_opcoes_atuais': opcoes_reais_para_escolha
    })
    
    # --- IN√çCIO DA CORRE√á√ÉO ---
    texto = f"Como *{nome_classe_exibido}*, voc√™ tem aptid√£o em diversas √°reas. Escolha *{num_escolhas_total}* per√≠cia(s) da lista abaixo para se especializar.\n\nEscolha sua primeira per√≠cia:"
    
    # Criar uma lista simples de bot√µes, cada um em sua pr√≥pria linha.
    # Isso √© mais seguro e evita erros de formata√ß√£o com o Telegram.
    botoes_simples = []
    for pericia in opcoes_reais_para_escolha:
        botoes_simples.append(
            [{'text': pericia, 'callback_data': f'skill_choice:{pericia}'}]
        )

    reply_markup = {'inline_keyboard': botoes_simples}
    
    # A mensagem anterior (escolha de classe/habilidade) j√° foi editada para confirmar.
    # Esta sempre ser√° uma NOVA mensagem com os bot√µes de per√≠cia.
    telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, texto, reply_markup)
    # --- FIM DA CORRE√á√ÉO ---


def _apresentar_escolhas_iniciais_classe(config, chat_id, message_id, classe_escolhida, player_ref, ficha_em_criacao):
    habilidades_nivel_1 = [h for h in config.CLASSES_DATA[classe_escolhida].get('habilidades', []) if h['nivel'] == 1]
    nome_classe_exibido = config.CLASSES_DATA[classe_escolhida].get('nome_exibido', classe_escolhida)
    texto_base_escolha = f"Como um(a) *{nome_classe_exibido}*,"

    if classe_escolhida == 'clerigo':
        dominios = [h for h in habilidades_nivel_1 if "Dom√≠nio Divino:" in h['nome']]
        if dominios:
            texto = f"{texto_base_escolha} sua f√© se manifesta atrav√©s de um Dom√≠nio Divino. Qual voc√™ devotar√°?"
            botoes = [[{'text': f"Dom√≠nio: {d['nome'].split(': ')[-1].replace(' (Exemplo)','')}", 'callback_data': f"subchoice:dominio:{d['nome']}"}] for d in dominios]
            telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, texto, {'inline_keyboard': botoes}); return
    elif classe_escolhida == 'guerreiro':
        estilos = [h for h in habilidades_nivel_1 if "Estilo de Luta" in h['nome']]
        if estilos:
            texto = f"{texto_base_escolha} seu treinamento lhe concedeu maestria em uma t√©cnica. Qual voc√™ aprimorou?"
            botoes = [[{'text': f"Estilo: {s['nome'].split(': ')[-1]}", 'callback_data': f"subchoice:estilo_luta:{s['nome']}"}] for s in estilos]
            telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, texto, {'inline_keyboard': botoes}); return
    
    habilidades_gerais_nv1 = [h for h in habilidades_nivel_1 if "Dom√≠nio Divino:" not in h['nome'] and ("Estilo de Luta" not in h['nome'] or classe_escolhida != 'guerreiro')]
    if habilidades_gerais_nv1 and len(habilidades_gerais_nv1) > 1 and classe_escolhida not in ['barbaro', 'bardo', 'mago', 'clerigo', 'guerreiro']:
        texto = f"{texto_base_escolha} voc√™ possui talentos √∫nicos. Escolha UMA habilidade inicial para focar:"
        botoes = [[{'text': hab['nome'], 'callback_data': f"ability_choice:{hab['nome']}"}] for hab in habilidades_gerais_nv1[:4]]
        telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, texto, {'inline_keyboard': botoes}); return

    habilidades_finais_nv1 = ficha_em_criacao.get('habilidades_aprendidas', [])
    for hab in habilidades_gerais_nv1:
        if hab['nome'] not in habilidades_finais_nv1: habilidades_finais_nv1.append(hab['nome'])
    
    oficio = config.CLASSES_DATA.get(classe_escolhida, {}).get('oficio', 'Nenhum'); mods = ficha_em_criacao.get('modificadores', {}); c_info = config.CLASSES_DATA.get(classe_escolhida, {})
    pv_max = ficha_em_criacao.get('pv_maximos', 0); ca_base = ficha_em_criacao.get('ca_base', 10 + mods.get('des',0))
    if pv_max == 0:
        if 'dado_vida' in c_info and 'con' in mods:
            try: v_dv = int(c_info['dado_vida'].replace('d','')); pv_max = v_dv + mods['con']
            except: pv_max = 8 + mods.get('con', 0)
        else: pv_max = 8 + mods.get('con', 0)
    
    player_ref.update({
        'ficha_em_criacao.habilidades_aprendidas': list(set(habilidades_finais_nv1)), 'ficha_em_criacao.oficio': oficio, 'ficha_em_criacao.pv_maximos': pv_max, 
        'ficha_em_criacao.pv_atuais': pv_max, 'ficha_em_criacao.ca_base': ca_base, 'ficha_em_criacao.bonus_proficiencia': 2, 'estado_criacao': 'AGUARDANDO_ESCOLHA_PERICIAS'
    })
    ficha_att_doc = player_ref.get(); ficha_para_pericias = ficha_att_doc.to_dict().get('ficha_em_criacao',{})
    telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, f"Talentos de *{nome_classe_exibido}* definidos!\nPV: {pv_max}, CA Base (sem armadura): {ca_base}.")
    _apresentar_escolha_pericias(config, chat_id, None, classe_escolhida, player_ref, ficha_para_pericias)

# ==============================================================================
# === HANDLERS DE CRIA√á√ÉO (FUN√á√ïES P√öBLICAS DO M√ìDULO)                      ===
# ==============================================================================

def handle_criar_personagem_command(config, user_id, chat_id, player_ref):
    """Inicia ou reinicia o fluxo de cria√ß√£o de personagem."""
    player_ref.set({
        'estado_criacao': 'AGUARDANDO_NOME',
        'ficha_em_criacao': {'pericias_proficientes': [], 'inventario': []},
        'historico': []
    }, merge=False)
    telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Vamos forjar seu destino... Por qual nome voc√™ √© conhecido?")

def handle_creation_message(config, user_id, chat_id, user_text, player_ref, player_data):
    """Trata as mensagens de texto durante a cria√ß√£o do personagem."""
    estado_atual = player_data.get('estado_criacao')
    
    if estado_atual == 'AGUARDANDO_NOME':
        player_ref.update({'estado_criacao': 'AGUARDANDO_RACA', 'ficha_em_criacao.nome': user_text})
        texto_raca = f"Excelente nome, *{user_text}*!\n\nCada povo em Aethel tem suas lendas e talentos. Qual √© a sua origem? Escolha sua Ra√ßa:"
        if config.RACAS_DATA:
            botoes_r = [[{'text': r_data['nome_exibido'], 'callback_data': f'race_choice:{r_key}'}] for r_key, r_data in config.RACAS_DATA.items()]
            botoes_r.sort(key=lambda r: r[0]['text'])
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, texto_raca, {'inline_keyboard': botoes_r})
        else:
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "AVISO: Ra√ßas n√£o carregadas. Pulando para atributos.")
            player_ref.update({'estado_criacao': 'AGUARDANDO_DISTRIBUICAO_ATRIBUTOS'})
            primeiro_val = utils.ARRAY_PADRAO_ATRIBUTOS[0]
            txt_dist = "Vamos distribuir seus Atributos usando os valores: 15, 14, 13, 12, 10, 8.\n"
            txt_dist += f"Come√ßando pelo valor mais alto, *{primeiro_val}*. Em qual atributo voc√™ deseja aplic√°-lo?"
            b_dist_buttons = []
            for attr_k_upper in utils.ATRIBUTOS_LISTA:
                b_dist_buttons.append({'text': f'{utils.obter_nome_completo_atributo(attr_k_upper)} ({attr_k_upper})', 'callback_data': f'distribute_attr:{primeiro_val}:{attr_k_upper}'})
            reply_markup_dist_fallback = {'inline_keyboard': [b_dist_buttons[i:i + 2] for i in range(0, len(b_dist_buttons), 2)]}
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, txt_dist, reply_markup_dist_fallback)

    elif estado_atual == 'AGUARDANDO_BACKGROUND':
        player_ref.update({'estado_criacao': 'AGUARDANDO_MOTIVACAO', 'ficha_em_criacao.background': user_text})
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Interessante... E toda jornada tem um come√ßo. O que te jogou na estrada em busca de aventura?")
    
    elif estado_atual == 'AGUARDANDO_MOTIVACAO':
        player_ref.update({'estado_criacao': 'AGUARDANDO_FALHA', 'ficha_em_criacao.motivacao': user_text})
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "At√© os maiores her√≥is t√™m uma fraqueza que os assombra. Qual √© a sua?")
        
    elif estado_atual == 'AGUARDANDO_FALHA':
        ficha_final_doc = player_ref.get()
        ficha_final = ficha_final_doc.to_dict().get('ficha_em_criacao', {})
        ficha_final['falha'] = user_text
        ficha_final.update({'nivel': 1, 'marcos': 0})
        
        if 'ca_final' not in ficha_final:
            ficha_final['ca_final'] = utils.calcular_ca_final_com_equipamento(
                ficha_final.get('ca_base', 10), ficha_final.get('inventario', []), ficha_final.get('modificadores', {}))
        
        if 'bonus_proficiencia' not in ficha_final: ficha_final['bonus_proficiencia'] = 2
        if 'recursos' not in ficha_final: ficha_final['recursos'] = {} 
        if 'magias' not in ficha_final: ficha_final['magias'] = {'conhecidas': [], 'preparadas': [], 'slots_n1_atuais': 0, 'slots_n1_max':0}
        
        player_ref.set({'ficha': ficha_final, 'historico': player_data.get('historico', [])}, merge=True)
        player_ref.update({'estado_criacao': firestore.DELETE_FIELD, 'ficha_em_criacao': firestore.DELETE_FIELD})
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Perfeito! Seu personagem est√° pronto!\n\nUse /start para iniciar sua jornada.")

def handle_creation_callback(config, user_id, chat_id, message_id, callback_data, player_ref, player_data):
    """Trata os cliques em bot√µes durante a cria√ß√£o do personagem."""
    ficha_em_criacao = player_data.get('ficha_em_criacao', {})
    
    if callback_data.startswith('race_choice:'):
        raca_key = callback_data.split(':', 1)[1]
        if raca_key not in config.RACAS_DATA:
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Ra√ßa inv√°lida."); return
        
        raca_info = config.RACAS_DATA[raca_key]
        ficha_em_criacao['raca'] = raca_key; ficha_em_criacao['nome_raca_exibido'] = raca_info['nome_exibido']
        ficha_em_criacao['tracos_raciais'] = raca_info.get('tracos_raciais', [])
        ficha_em_criacao['deslocamento'] = raca_info.get('deslocamento', 9)
        pericias_atuais = ficha_em_criacao.get('pericias_proficientes', [])
        if "Profici√™ncia (Percep√ß√£o)" in raca_info.get('tracos_raciais', []): pericias_atuais.append("Percep√ß√£o")
        ficha_em_criacao['pericias_proficientes'] = list(set(pericias_atuais))
        player_ref.update({'ficha_em_criacao': ficha_em_criacao, 'estado_criacao': 'AGUARDANDO_DISTRIBUICAO_ATRIBUTOS'})
        
        telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, f"Voc√™ escolheu ser um(a) *{raca_info['nome_exibido']}*.")
        
        primeiro_valor = utils.ARRAY_PADRAO_ATRIBUTOS[0]
        texto = f"Excelente escolha! Ser um(a) *{raca_info['nome_exibido']}* lhe confere certas aptid√µes.\n\nAgora, defina seus Atributos Fundamentais (15, 14, 13, 12, 10, 8).\n\nCome√ßando pelo valor mais alto, *{primeiro_valor}*. Em qual atributo voc√™ deseja aplic√°-lo?"
        botoes = []
        for attr_k in utils.ATRIBUTOS_LISTA: botoes.append({'text': f'{utils.obter_nome_completo_atributo(attr_k)} ({attr_k})', 'callback_data': f'distribute_attr:{primeiro_valor}:{attr_k}'})
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, texto, {'inline_keyboard': [botoes[i:i + 2] for i in range(0, len(botoes), 2)]})

    elif callback_data.startswith('distribute_attr:'):
        _, v_str, attr_key_upper = callback_data.split(':', 2); v_int = int(v_str)
        a_base = ficha_em_criacao.get('atributos_base', {}); v_pend = ficha_em_criacao.get('valores_atributos_pendentes', list(utils.ARRAY_PADRAO_ATRIBUTOS))
        
        if attr_key_upper.lower() in a_base: telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, f"Atributo {utils.obter_nome_completo_atributo(attr_key_upper)} j√° definido."); return
        if v_int not in v_pend: telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, f"Valor {v_int} n√£o dispon√≠vel."); return
        
        a_base[attr_key_upper.lower()] = v_int; v_pend.remove(v_int)
        player_ref.update({'ficha_em_criacao.atributos_base': a_base, 'ficha_em_criacao.valores_atributos_pendentes': v_pend})
        
        if not v_pend:
            a_finais = dict(a_base); r_key = ficha_em_criacao.get('raca')
            if r_key and r_key in config.RACAS_DATA:
                ajustes = config.RACAS_DATA[r_key].get('ajustes_atributo', {});
                for attr_k, bonus in ajustes.items(): a_finais[attr_k] = a_finais.get(attr_k, 0) + bonus
            mods = {attr: utils.calcular_modificador(val) for attr, val in a_finais.items()}
            player_ref.update({'estado_criacao': 'AGUARDANDO_CLASSE', 'ficha_em_criacao.atributos': a_finais, 'ficha_em_criacao.modificadores': mods})
            telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, f"Voc√™ atribuiu {v_int} para {utils.obter_nome_completo_atributo(attr_key_upper)}.\nAtributos base definidos. B√¥nus raciais aplicados!")
            
            # --- IN√çCIO DA CORRE√á√ÉO ---
            texto_resumo_atributos = "Perfeito! Seus Atributos Finais s√£o:\n"
            resumo_linhas = []
            for attr_k_l, attr_v in a_finais.items():
                mod = mods.get(attr_k_l, 0)
                sinal_mod = '+' if mod >= 0 else ''
                resumo_linhas.append(f"{utils.obter_nome_completo_atributo(attr_k_l.upper())}: {attr_v} (Mod: {sinal_mod}{mod})")
            
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, texto_resumo_atributos + "\n".join(resumo_linhas))
            
            texto_escolha_classe = "\nAgora, escolha sua voca√ß√£o, seu chamado para a aventura:"
            botoes_classes = [[{'text': c_d['nome_exibido'], 'callback_data': f'class_choice:{c_k}'}] for c_k, c_d in config.CLASSES_DATA.items()]
            botoes_classes.sort(key=lambda r: r[0]['text'])
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, texto_escolha_classe, {'inline_keyboard': botoes_classes})
            # --- FIM DA CORRE√á√ÉO ---
        else:
            prox_v = v_pend[0]; attrs_d = [a_k for a_k in utils.ATRIBUTOS_LISTA if a_k.lower() not in a_base]
            texto_n = f"Voc√™ atribuiu {v_int} para {utils.obter_nome_completo_atributo(attr_key_upper)}.\n\nPr√≥ximo valor a distribuir: *{prox_v}*. Em qual atributo restante voc√™ o aplicar√°?"
            b_prox = [];
            for a_d_k in attrs_d: b_prox.append({'text': f'{utils.obter_nome_completo_atributo(a_d_k)} ({a_d_k})', 'callback_data': f'distribute_attr:{prox_v}:{a_d_k}'})
            telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, texto_n, {'inline_keyboard': [b_prox[i:i + 2] for i in range(0, len(b_prox), 2)]})

    elif callback_data.startswith('class_choice:'):
        c_key = callback_data.split(':', 1)[1]; c_info = config.CLASSES_DATA.get(c_key, {})
        p_fixas = c_info.get('pericias_fixas', []); p_atuais = ficha_em_criacao.get('pericias_proficientes', [])
        for p_f in p_fixas:
            if p_f not in p_atuais: p_atuais.append(p_f)
        player_ref.update({'estado_criacao': 'AGUARDANDO_HABILIDADE_INICIAL', 'ficha_em_criacao.classe': c_key, 'ficha_em_criacao.pericias_proficientes': list(set(p_atuais))})
        f_att_doc = player_ref.get(); f_para_habs = f_att_doc.to_dict().get('ficha_em_criacao', {})
        _apresentar_escolhas_iniciais_classe(config, chat_id, message_id, c_key, player_ref, f_para_habs)

    elif callback_data.startswith('subchoice:') or callback_data.startswith('ability_choice:'):
        parts = callback_data.split(':', 2)
        tipo_esc, subtipo_ou_hab, hab_final = parts[0], parts[1], parts[2] if tipo_esc == 'subchoice' else parts[1]
        classe_p = ficha_em_criacao.get('classe');
        if not classe_p: telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Erro: Classe n√£o definida. Reinicie."); return
        habs_atuais = ficha_em_criacao.get('habilidades_aprendidas', []);
        if hab_final not in habs_atuais: habs_atuais.append(hab_final)
        habs_nv1 = [h for h in config.CLASSES_DATA.get(classe_p, {}).get('habilidades', []) if h['nivel'] == 1]
        for hab_p in habs_nv1:
            is_sub = "Dom√≠nio Divino:" in hab_p['nome'] or "Estilo de Luta" in hab_p['nome']
            if hab_p['nome'] != hab_final and not is_sub and hab_p['nome'] not in habs_atuais: habs_atuais.append(hab_p['nome'])
        player_ref.update({'ficha_em_criacao.habilidades_aprendidas': list(set(habs_atuais)), 'estado_criacao': 'AGUARDANDO_ESCOLHA_PERICIAS'})
        f_para_pericias_doc = player_ref.get(); f_para_pericias = f_para_pericias_doc.to_dict().get('ficha_em_criacao',{})
        _apresentar_escolha_pericias(config, chat_id, message_id, classe_p, player_ref, f_para_pericias)

    elif callback_data.startswith('skill_choice:'):
        p_esc = callback_data.split(':',1)[1]
        p_prof = ficha_em_criacao.get('pericias_proficientes', []); p_rest = ficha_em_criacao.get('pericias_escolhas_restantes', 0); p_opts = ficha_em_criacao.get('pericias_opcoes_atuais', [])
        
        if p_esc in p_prof: telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "J√° proficiente. Escolha outra."); return
        if p_esc not in p_opts: telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Op√ß√£o inv√°lida."); return
        
        p_prof.append(p_esc); p_rest -= 1;
        if p_esc in p_opts: p_opts.remove(p_esc)
        
        player_ref.update({
            'ficha_em_criacao.pericias_proficientes': list(set(p_prof)),
            'ficha_em_criacao.pericias_escolhas_restantes': p_rest,
            'ficha_em_criacao.pericias_opcoes_atuais': p_opts
        })
        
        if p_rest <= 0 or not p_opts:
            c_key = ficha_em_criacao.get('classe'); c_info = config.CLASSES_DATA.get(c_key,{})
            equipamento = c_info.get('equipamento_inicial', []); inv = ficha_em_criacao.get('inventario', [])
            for item_novo in equipamento:
                n_novo = item_novo.get("nome") if isinstance(item_novo, dict) else item_novo
                if not any((i.get("nome") if isinstance(i, dict) else i) == n_novo for i in inv): inv.append(item_novo)
            ca_final = utils.calcular_ca_final_com_equipamento(
                ficha_em_criacao.get('ca_base', 10), inv, ficha_em_criacao.get('modificadores',{}))
            
            player_ref.update({
                'estado_criacao': 'AGUARDANDO_BACKGROUND', 'ficha_em_criacao.inventario': inv, 'ficha_em_criacao.ca_final': ca_final,
                'ficha_em_criacao.pericias_escolhas_restantes': firestore.DELETE_FIELD, 'ficha_em_criacao.pericias_opcoes_atuais': firestore.DELETE_FIELD
            })
            telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, f"Per√≠cia *{p_esc}* adicionada. Todas as per√≠cias de classe foram escolhidas.")
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, f"Equipamento inicial adicionado. Sua CA Final √© *{ca_final}*.\n\nAgora, vamos √† sua hist√≥ria. O que voc√™ fazia?")
        else:
            texto = f"Per√≠cia *{p_esc}* adicionada.\nEscolha mais {p_rest} per√≠cia(s):"
            b_prox = [[{'text': p, 'callback_data': f'skill_choice:{p}'}] for p in p_opts]
            reply_markup = {'inline_keyboard': [b_prox[i:i + 3] for i in range(0, len(b_prox), 3)] if len(b_prox) > 3 else b_prox}
            telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, texto, reply_markup)


adventure_handler.py
# modules/game_logic/adventure_handler.py
import json
import random
import urllib.parse
from firebase_admin import firestore
from modules import telegram_actions
from modules.game_logic import utils

# ==============================================================================
# === HANDLERS DE COMANDOS DO MODO AVENTURA                                  ===
# ==============================================================================

def handle_start_command(config, user_id, chat_id, player_doc):
    """Lida com o comando /start."""
    if player_doc.exists and 'ficha' in player_doc.to_dict():
        nome_personagem = player_doc.to_dict().get('ficha', {}).get('nome', 'Aventureiro(a)')
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, f"Bem-vindo(a) de volta, {nome_personagem}! Sua aventura nas Terras de Aethel continua...")
    else:
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Sua lenda ainda n√£o foi escrita. Use /criar_personagem para forjar seu destino.")

def handle_ficha_command(config, user_id, chat_id, player_doc):
    """Lida com o comando /ficha."""
    # Substitua pela sua URL do Firebase Hosting
    hosting_url = "https://meu-rpg-duna.web.app"
    if player_doc.exists and 'ficha' in player_doc.to_dict():
        teclado = {'inline_keyboard': [[{'text': 'üìú Abrir Ficha de Personagem', 'web_app': {'url': hosting_url}}]]}
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Aqui est√° sua ficha de aventureiro. Clique no bot√£o abaixo para abri-la.", teclado)
    else:
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Voc√™ precisa criar um personagem primeiro! Use o comando /criar_personagem.")

# ==============================================================================
# === HANDLERS DE A√á√ïES DO MODO AVENTURA (MENSAGENS E CALLBACKS)             ===
# ==============================================================================

def handle_adventure_message(config, user_id, chat_id, user_text, player_ref, player_data):
    """Trata as mensagens de texto no modo aventura."""
    ficha = player_data.get('ficha', {})
    historico = player_data.get('historico', [])

    # L√≥gica para o comando /atacar
    if user_text.lower().startswith('/atacar'):
        arma_equipada = None
        for item in ficha.get('inventario', []):
            if isinstance(item, dict) and item.get('tipo', '') == 'arma_equipavel':
                arma_equipada = item
                break
        
        if not arma_equipada:
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Nenhuma arma equip√°vel encontrada!")
            return

        nome_arma = arma_equipada.get('nome', 'arma')
        propriedades_arma = arma_equipada.get('propriedades_arma', [])
        atributo_padrao_arma = arma_equipada.get('atributo_padrao', 'for')
        modificadores = ficha.get('modificadores', {})
        
        attr_ataque = atributo_padrao_arma
        if "acuidade" in propriedades_arma and modificadores.get('des', -5) > modificadores.get('for', -5):
            attr_ataque = 'des'
        
        bonus_attr = modificadores.get(attr_ataque, 0)
        bonus_prof = ficha.get('bonus_proficiencia', 2)
        bonus_total = bonus_attr
        
        proficiencias_armas = config.CLASSES_DATA.get(ficha.get('classe'), {}).get('proficiencia_armas', [])
        tipo_arma_prof = arma_equipada.get("tipo_arma_prof", "simples")
        is_proficiente = tipo_arma_prof in proficiencias_armas

        if is_proficiente:
            bonus_total += bonus_prof

        alvo = user_text.split(' ', 1)[1] if len(user_text.split(' ', 1)) > 1 else "um oponente"
        alvo_enc = urllib.parse.quote_plus(alvo)
        arma_enc = urllib.parse.quote_plus(nome_arma)
        
        texto_info = f"Voc√™ empunha sua *{nome_arma}* e mira em *{alvo}*!\nSeu b√¥nus para acertar √© *+{bonus_total}* (Base {attr_ataque.upper()}: {bonus_attr}, Prof: +{bonus_prof if is_proficiente else 0})."
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, texto_info)
        
        teclado = {'inline_keyboard': [[{'text': f'‚öîÔ∏è Tentar Acertar {alvo} (Rolar d20)', 'callback_data': f'ataque_rolar_d20:{alvo_enc}:{arma_enc}:{bonus_total}:{attr_ataque}'}]]}
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Fa√ßa sua rolagem de ataque!", teclado)
        return

    # L√≥gica para a√ß√µes gen√©ricas
    try:
        prompt_arbitro = config.PROMPTS['arbitro'].format(user_text)
        convo_arbitro = config.model.start_chat(history=[])
        response_arbitro_obj = convo_arbitro.send_message(prompt_arbitro)
        resposta_arbitro = response_arbitro_obj.text.strip().upper()
    except Exception as e_gemini_arb:
        print(f"ERROR: [adventure_handler] Erro ao chamar Gemini (√Årbitro) para user_id {user_id}: {e_gemini_arb}")
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "O Or√°culo do Destino (IA √Årbitro) est√° momentaneamente confuso. Tente uma a√ß√£o diferente.")
        return

    entrada_jogador_hist = {"role": "user", "parts": [user_text]}
    if resposta_arbitro == "SIM":
        texto_pergunta = "O destino √© incerto. Teste sua sorte."
        teclado = {'inline_keyboard': [[{'text': 'üé≤ Rolar d20 (A√ß√£o Geral)', 'callback_data': 'roll_d20'}]]}
        sent_message = telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, texto_pergunta, teclado)
        if sent_message and sent_message.get('ok'):
            player_ref.update({'acao_pendente': user_text, 'id_mensagem_dado': sent_message['result']['message_id']})
    else: # "N√ÉO"
        try:
            prompt_simples_fmt = config.PROMPTS['narrador_simples'].format(user_text, json.dumps(ficha, ensure_ascii=False, default=str))
            convo_simples = config.model.start_chat(history=[{"role": msg["role"], "parts": msg["parts"]} for msg in historico])
            response_simples = convo_simples.send_message(prompt_simples_fmt)
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, response_simples.text)
            entrada_modelo_hist = {"role": "model", "parts": [response_simples.text]}
            player_ref.update({'historico': firestore.ArrayUnion([entrada_jogador_hist, entrada_modelo_hist])})
        except Exception as e_gemini_narr:
            print(f"ERROR: [adventure_handler] Erro ao chamar Gemini (Narrador Simples) para user_id {user_id}: {e_gemini_narr}")
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "O Mestre dos Contos trope√ßou em suas palavras. Tente novamente.")

def handle_adventure_callback(config, user_id, chat_id, message_id, callback_data, player_ref, player_data):
    """Trata os cliques em bot√µes no modo aventura."""
    ficha = player_data.get('ficha', {})
    historico = player_data.get('historico', [])

    if callback_data == 'roll_d20':
        acao_pendente = player_data.get('acao_pendente')
        if acao_pendente:
            resultado_d20 = random.randint(1, 20)
            telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, f"Voc√™ lan√ßa seu destino aos ventos... o resultado do dado √© *{resultado_d20}*!")
            entrada_user_hist = {"role": "user", "parts": [acao_pendente]}
            hist_para_gemini = historico + [entrada_user_hist]
            prompt = config.PROMPTS['mestre_narrador'].format(json.dumps(ficha, ensure_ascii=False), json.dumps(hist_para_gemini, ensure_ascii=False), acao_pendente, resultado_d20)
            convo = config.model.start_chat(history=[{"role": m["role"], "parts": m["parts"]} for m in historico])
            response = convo.send_message(prompt)
            telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, response.text)
            entrada_model_hist = {"role": "model", "parts": [response.text]}
            player_ref.update({'acao_pendente': firestore.DELETE_FIELD, 'id_mensagem_dado': firestore.DELETE_FIELD, 'historico': firestore.ArrayUnion([entrada_user_hist, entrada_model_hist])})
    
    elif callback_data.startswith('ataque_rolar_d20:'):
        parts = callback_data.split(':', 4)
        alvo_enc, arma_enc, bonus_str, attr_atk = parts[1], parts[2], parts[3], parts[4]
        alvo = urllib.parse.unquote_plus(alvo_enc); arma = urllib.parse.unquote_plus(arma_enc); bonus = int(bonus_str)
        d20_puro = random.randint(1, 20); total_atk = d20_puro + bonus
        telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, f"Atacando {alvo} com {arma}...\nd20: *{d20_puro}* + B√¥nus (+{bonus}) = Total: *{total_atk}*")
        
        acao_atk = f"Ataca {alvo} com {arma} (rolagem d20:{d20_puro}, total ataque:{total_atk})."
        hist_user = {"role": "user", "parts": [acao_atk]}; hist_gemini = historico + [hist_user]
        prompt = config.PROMPTS['mestre_narrador'].format(json.dumps(ficha, ensure_ascii=False), json.dumps(hist_gemini, ensure_ascii=False), f"Atacar {alvo} com {arma}", d20_puro)
        
        convo = config.model.start_chat(history=[{"role": m["role"], "parts": m["parts"]} for m in historico])
        response = convo.send_message(prompt); nar_acerto = response.text
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, nar_acerto)
        hist_model = {"role": "model", "parts": [nar_acerto]}
        
        acerto_ok = any(p in nar_acerto.lower() for p in ["acerta", "atinge", "consegue ferir", "golpe certeiro", "impacta", "conecta"])
        if acerto_ok:
            arma_info = next((item for item in ficha.get('inventario', []) if isinstance(item, dict) and item.get('nome') == arma), None)
            if arma_info:
                dado_dano, tipo_dano = arma_info.get('dado_dano', '1d4'), arma_info.get('tipo_dano_arma', 'concuss√£o')
                attr_dano = arma_info.get('atributo_padrao', attr_atk)
                if "acuidade" in arma_info.get('propriedades_arma', []) and ficha.get('modificadores',{}).get('des',-5) > ficha.get('modificadores',{}).get('for',-5): attr_dano = 'des'
                dado_dano_enc = urllib.parse.quote_plus(dado_dano)
                teclado = {'inline_keyboard': [[{'text': f'üí• Rolar Dano ({dado_dano}) com {arma}', 'callback_data': f'ataque_rolar_dano:{alvo_enc}:{arma_enc}:{attr_dano}:{dado_dano_enc}:{tipo_dano}'}]]}
                telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, "Seu golpe conectou! Determine o estrago:", teclado)
                player_ref.update({'historico': firestore.ArrayUnion([hist_user, hist_model])})
            else:
                telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, f"(Mestre: N√£o encontrei {arma} para dano.)")
                player_ref.update({'historico': firestore.ArrayUnion([hist_user, hist_model])})
        else:
            player_ref.update({'historico': firestore.ArrayUnion([hist_user, hist_model])})

    elif callback_data.startswith('ataque_rolar_dano:'):
        parts = callback_data.split(':', 5)
        alvo_enc, arma_enc, attr_dano, dado_dano_enc, tipo_dano = parts[1], parts[2], parts[3], parts[4], parts[5]
        alvo, arma, dado_dano_str = urllib.parse.unquote_plus(alvo_enc), urllib.parse.unquote_plus(arma_enc), urllib.parse.unquote_plus(dado_dano_enc)
        
        mods = ficha.get('modificadores', {}); mod_dano = mods.get(attr_dano, 0)
        dano_total, rol_str = utils.rolar_dados_dano(dado_dano_str, mod_dano)
        
        telegram_actions.edit_telegram_message(config.TELEGRAM_TOKEN, chat_id, message_id, 
            f"Dano com *{arma}* em *{alvo}*:\nDados: {dado_dano_str}\nRolagem: {rol_str}\nTotal: *{dano_total}* de dano *{tipo_dano}*!")
        
        acao_dano = f"Causa {dano_total} de dano {tipo_dano} em {alvo} com {arma}."
        hist_user_dano = {"role": "user", "parts": [acao_dano]}; hist_gemini_dano = historico + [hist_user_dano]
        prompt = config.PROMPTS['mestre_narrador'].format(json.dumps(ficha, ensure_ascii=False), json.dumps(hist_gemini_dano, ensure_ascii=False), acao_dano, 0)
        
        convo = config.model.start_chat(history=[{"role": m["role"], "parts": m["parts"]} for m in historico])
        response = convo.send_message(prompt)
        telegram_actions.send_telegram_message(config.TELEGRAM_TOKEN, chat_id, response.text)
        hist_model_dano = {"role": "model", "parts": [response.text]}
        player_ref.update({'historico': firestore.ArrayUnion([hist_user_dano, hist_model_dano])})


racas.json
{
    "humano": {
      "nome_exibido": "Humano",
      "descricao": "Adapt√°veis e ambiciosos, os humanos s√£o a ra√ßa mais comum, conhecida por sua diversidade e tenacidade.",
      "ajustes_atributo": {
        "for": 1, "des": 1, "con": 1, "int": 1, "sab": 1, "car": 1
      },
      "deslocamento": 9,
      "tracos_raciais": ["Vers√°til", "Um Idioma Adicional (Abstrato)"]
    },
    "elfo": {
      "nome_exibido": "Elfo (Alto Elfo)",
      "descricao": "Graciosos e conectados √† magia ancestral, os altos elfos valorizam o conhecimento e as artes arcanas.",
      "ajustes_atributo": { "des": 2, "int": 1 },
      "deslocamento": 9,
      "tracos_raciais": ["Vis√£o no Escuro", "Heran√ßa Fe√©rica", "Transe", "Profici√™ncia (Percep√ß√£o)", "Truque de Mago (Abstrato)"]
    },
    "anao": {
      "nome_exibido": "An√£o (da Montanha)",
      "descricao": "Resistentes e habilidosos artes√£os, os an√µes da montanha s√£o conhecidos por sua for√ßa e lealdade.",
      "ajustes_atributo": { "for": 2, "con": 2 },
      "deslocamento": 7.5,
      "tracos_raciais": ["Vis√£o no Escuro", "Resili√™ncia An√£", "Treinamento de Combate An√£o (Machados, Machadinhas, Martelos)", "Profici√™ncia (Ferramentas de Ferreiro - Abstrato)"]
    },
    "halfling": {
      "nome_exibido": "Halfling (P√©s Leves)",
      "descricao": "Alegres e curiosos, os halflings p√©s leves s√£o conhecidos por sua sorte e habilidade de se misturar.",
      "ajustes_atributo": { "des": 2, "car": 1 },
      "deslocamento": 7.5,
      "tracos_raciais": ["Sortudo", "Bravura", "Agilidade Halfling", "Furtividade Natural"]
    }
  }

classes.json
{
    "guerreiro": {
      "nome_exibido": "Guerreiro",
      "descricao": "Mestre de armas e t√°ticas, o guerreiro √© a espinha dorsal de qualquer grupo de aventureiros.",
      "oficio": "Forja de Armas",
      "dado_vida": "d10",
      "pericias_fixas": [],
      "pericias_escolha_num": 2,
      "pericias_opcoes": ["Acrobacia", "Adestrar Animais", "Atletismo", "Hist√≥ria", "Intimida√ß√£o", "Intui√ß√£o", "Percep√ß√£o", "Sobreviv√™ncia"],
      "proficiencia_armas": ["simples", "marciais"],
      "equipamento_inicial": [
        { "nome": "Cota de Malha", "tipo": "armadura_pesada_ref", "ca_base": 16 },
        { "nome": "Espada Longa", "tipo": "arma_equipavel", "tipo_arma_prof": "marcial", "atributo_padrao": "for", "dado_dano": "1d8", "tipo_dano_arma": "cortante", "propriedades_arma": ["vers√°til (1d10)"]},
        { "nome": "Escudo", "tipo": "armadura_aux", "ca_bonus": 2 },
        { "nome": "Duas Machadinhas", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "for", "dado_dano": "1d6", "tipo_dano_arma": "cortante", "propriedades_arma": ["leve", "arremesso (6/18m)"], "quantidade": 2}
      ],
      "habilidades": [
        { "nome": "Estilo de Luta: Defesa", "nivel": 1, "descricao": "Enquanto estiver usando armadura, voc√™ ganha +1 de b√¥nus na CA." },
        { "nome": "Estilo de Luta: Duelo", "nivel": 1, "descricao": "Quando empunha uma arma corpo-a-corpo em uma s√≥ m√£o e nenhuma outra, voc√™ ganha +2 de b√¥nus nas rolagens de dano com essa arma." },
        { "nome": "Estilo de Luta: Arquearia", "nivel": 1, "descricao": "Voc√™ ganha +2 de b√¥nus nas rolagens de ataque com armas de ataque √† dist√¢ncia." },
        { "nome": "Estilo de Luta: Grandes Armas", "nivel": 1, "descricao": "Quando rolar 1 ou 2 num dado de dano de um ataque com arma corpo-a-corpo que esteja empunhando com as duas m√£os, voc√™ pode rolar o dado novamente e deve usar a nova rolagem." },
        { "nome": "Retomar o F√¥lego", "nivel": 1, "descricao": "No seu turno, voc√™ pode usar uma a√ß√£o b√¥nus para recuperar PV igual a 1d10 + seu n√≠vel de guerreiro. Voc√™ precisa terminar um descanso curto ou longo antes de usar esta caracter√≠stica novamente." },
        { "nome": "Surto de A√ß√£o", "nivel": 2, "descricao": "No seu turno, voc√™ pode realizar uma a√ß√£o adicional. Uma vez que usar esta caracter√≠stica, voc√™ precisa terminar um descanso curto ou longo para us√°-la novamente." },
        { "nome": "Arqu√©tipo Marcial: Campe√£o", "nivel": 3, "descricao": "Seus ataques com armas t√™m uma margem de cr√≠tico de 19-20." },
        { "nome": "Arqu√©tipo Marcial: Mestre de Batalha", "nivel": 3, "descricao": "Voc√™ aprende manobras que s√£o abastecidas por dados de superioridade especiais." },
        { "nome": "Arqu√©tipo Marcial: Cavaleiro Arcano", "nivel": 3, "descricao": "Voc√™ combina proeza marcial com magia." },
        { "nome": "Ataque Extra", "nivel": 5, "descricao": "Voc√™ pode atacar duas vezes, em vez de uma, sempre que usar a a√ß√£o Atacar no seu turno." }
      ]
    },
    "mago": {
      "nome_exibido": "Mago",
      "descricao": "Um estudioso da trama da realidade, o mago manipula as energias arcanas.",
      "oficio": "Caligrafia Arcana",
      "dado_vida": "d6",
      "pericias_fixas": [],
      "pericias_escolha_num": 2,
      "pericias_opcoes": ["Arcanismo", "Hist√≥ria", "Intui√ß√£o", "Investiga√ß√£o", "Medicina", "Religi√£o"],
      "proficiencia_armas": ["adagas", "dardos", "fundas", "cajados", "bestas leves"],
      "equipamento_inicial": [
        { "nome": "Cajado", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "for", "dado_dano": "1d6", "tipo_dano_arma": "concuss√£o", "propriedades_arma": ["vers√°til (1d8)"] },
        { "nome": "Grim√≥rio", "tipo": "item_chave" },
        { "nome": "Bolsa de Componentes", "tipo": "item_chave_foco_arcano" }
      ],
      "habilidades": [
        { "nome": "Conjura√ß√£o (Mago)", "nivel": 1, "descricao": "Voc√™ conhece truques e pode preparar magias do seu grim√≥rio." },
        { "nome": "Recupera√ß√£o Arcana", "nivel": 1, "descricao": "Ap√≥s um descanso curto, voc√™ pode recuperar alguns espa√ßos de magia gastos." },
        { "nome": "Tradi√ß√£o Arcana: Escola de Abjura√ß√£o", "nivel": 2, "descricao": "Foco em magias de prote√ß√£o e banimento." },
        { "nome": "Tradi√ß√£o Arcana: Escola de Evoca√ß√£o", "nivel": 2, "descricao": "Foco em magias de dano elemental." },
        { "nome": "Tradi√ß√£o Arcana: Escola de Ilus√£o", "nivel": 2, "descricao": "Foco em enganar os sentidos." }
      ]
    },
    "ladino": {
      "nome_exibido": "Ladino",
      "descricao": "Mestre das sombras, das habilidades e das oportunidades.",
      "oficio": "Cria√ß√£o de Ferramentas/Venenos",
      "dado_vida": "d8",
      "pericias_fixas": [],
      "pericias_escolha_num": 4,
      "pericias_opcoes": ["Acrobacia", "Atletismo", "Atua√ß√£o", "Engana√ß√£o", "Furtividade", "Intimida√ß√£o", "Intui√ß√£o", "Investiga√ß√£o", "Percep√ß√£o", "Persuas√£o", "Prestidigita√ß√£o"],
      "proficiencia_armas": ["simples", "bestas de m√£o", "espadas longas", "rapieiras", "espadas curtas"],
      "equipamento_inicial": [
        { "nome": "Rapieira", "tipo": "arma_equipavel", "tipo_arma_prof": "marcial", "atributo_padrao": "des", "dado_dano": "1d8", "tipo_dano_arma": "perfurante", "propriedades_arma": ["acuidade"] },
        { "nome": "Adaga", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "des", "dado_dano": "1d4", "tipo_dano_arma": "perfurante", "propriedades_arma": ["acuidade", "leve", "arremesso (6/18m)"], "quantidade": 2 },
        { "nome": "Arco Curto", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "des", "dado_dano": "1d6", "tipo_dano_arma": "perfurante", "propriedades_arma": ["muni√ß√£o (24/96m)", "duas m√£os"] },
        { "nome": "Aljava com 20 Flechas", "tipo": "municao" },
        { "nome": "Armadura de Couro", "tipo": "armadura_leve_ref", "ca_base": 11 },
        { "nome": "Ferramentas de Ladr√£o", "tipo": "ferramenta" }
      ],
      "habilidades": [
        { "nome": "Especializa√ß√£o", "nivel": 1, "descricao": "Escolha duas de suas profici√™ncias em per√≠cias. Seu b√¥nus de profici√™ncia √© dobrado para qualquer teste de habilidade que voc√™ fizer com elas." },
        { "nome": "Ataque Furtivo", "nivel": 1, "descricao": "Uma vez por turno, pode causar dano extra (1d6 no n√≠vel 1) a uma criatura que voc√™ atinge com um ataque se tiver vantagem ou um aliado adjacente." },
        { "nome": "G√≠ria de Ladr√£o", "nivel": 1, "descricao": "Voc√™ conhece os c√≥digos secretos, dialetos e sinais usados por ladr√µes." },
        { "nome": "A√ß√£o Ardilosa", "nivel": 2, "descricao": "Voc√™ pode usar uma a√ß√£o b√¥nus para Correr, Desengajar ou se Esconder." },
        { "nome": "Arqu√©tipo Ladino: Assassino", "nivel": 3, "descricao": "Voc√™ √© um mestre em emboscadas e ataques letais." },
        { "nome": "Arqu√©tipo Ladino: Ladr√£o", "nivel": 3, "descricao": "Suas m√£os s√£o incrivelmente r√°pidas para usar objetos e desarmar armadilhas." },
        { "nome": "Arqu√©tipo Ladino: Trapaceiro Arcano", "nivel": 3, "descricao": "Voc√™ incrementa suas habilidades ladinas com magia." }
      ]
    },
    "clerigo": {
      "nome_exibido": "Cl√©rigo",
      "descricao": "Um canal da vontade de uma divindade, o cl√©rigo √© um farol de f√©.",
      "oficio": "Alquimia Sagrada",
      "dado_vida": "d8",
      "pericias_fixas": [],
      "pericias_escolha_num": 2,
      "pericias_opcoes": ["Hist√≥ria", "Intui√ß√£o", "Medicina", "Persuas√£o", "Religi√£o"],
      "proficiencia_armas": ["simples"],
      "equipamento_inicial": [
        { "nome": "Ma√ßa", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "for", "dado_dano": "1d6", "tipo_dano_arma": "concuss√£o" },
        { "nome": "Armadura de Escamas", "tipo": "armadura_media_ref", "ca_base": 14 },
        { "nome": "Escudo", "tipo": "armadura_aux", "ca_bonus": 2 },
        { "nome": "S√≠mbolo Sagrado", "tipo": "item_chave_foco_divino" }
      ],
      "habilidades": [
        { "nome": "Conjura√ß√£o (Cl√©rigo)", "nivel": 1, "descricao": "Voc√™ pode preparar e conjurar magias divinas." },
        { "nome": "Dom√≠nio Divino: Vida", "nivel": 1, "descricao": "Suas magias de cura s√£o mais potentes. Voc√™ ganha profici√™ncia com armadura pesada." },
        { "nome": "Dom√≠nio Divino: Luz", "nivel": 1, "descricao": "Voc√™ pode usar sua rea√ß√£o para impor desvantagem cegando um inimigo com luz divina." },
        { "nome": "Dom√≠nio Divino: Guerra", "nivel": 1, "descricao": "Voc√™ pode realizar um ataque extra como a√ß√£o b√¥nus. Ganha profici√™ncia com armas marciais e armadura pesada." },
        { "nome": "Dom√≠nio Divino: Conhecimento", "nivel": 1, "descricao": "Voc√™ ganha profici√™ncias e pode usar Canalizar Divindade para per√≠cias." },
        { "nome": "Dom√≠nio Divino: Natureza", "nivel": 1, "descricao": "Voc√™ ganha per√≠cias e pode encantar animais e plantas." },
        { "nome": "Dom√≠nio Divino: Tempestade", "nivel": 1, "descricao": "Voc√™ ganha profici√™ncias e pode retaliar com dano de trov√£o." },
        { "nome": "Dom√≠nio Divino: Trapa√ßa", "nivel": 1, "descricao": "Voc√™ pode criar ilus√µes e ter vantagem em furtividade." },
        { "nome": "Canalizar Divindade: Expulsar Mortos-Vivos", "nivel": 2, "descricao": "Voc√™ pode usar seu s√≠mbolo sagrado para repelir mortos-vivos." }
      ]
    },
    "barbaro": {
      "nome_exibido": "B√°rbaro",
      "descricao": "Vindo das fronteiras selvagens, o b√°rbaro √© uma for√ßa da natureza.",
      "oficio": "Curtume e Ca√ßa",
      "dado_vida": "d12",
      "pericias_fixas": [],
      "pericias_escolha_num": 2,
      "pericias_opcoes": ["Adestrar Animais", "Atletismo", "Intimida√ß√£o", "Natureza", "Percep√ß√£o", "Sobreviv√™ncia"],
      "proficiencia_armas": ["simples", "marciais"],
      "equipamento_inicial": [
        { "nome": "Machado Grande", "tipo": "arma_equipavel", "tipo_arma_prof": "marcial", "atributo_padrao": "for", "dado_dano": "1d12", "tipo_dano_arma": "cortante", "propriedades_arma": ["pesada", "duas m√£os"] },
        { "nome": "Duas Machadinhas", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "for", "dado_dano": "1d6", "tipo_dano_arma": "cortante", "propriedades_arma": ["leve", "arremesso (6/18m)"], "quantidade": 2 },
        { "nome": "Quatro Azagaias", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "for", "dado_dano": "1d6", "tipo_dano_arma": "perfurante", "propriedades_arma": ["arremesso (9/36m)"], "quantidade": 4 }
      ],
      "habilidades": [
        { "nome": "F√∫ria", "nivel": 1, "descricao": "Em combate, voc√™ pode entrar em f√∫ria, ganhando b√¥nus em ataques de For√ßa, dano e resist√™ncia a dano." },
        { "nome": "Defesa sem Armadura (B√°rbaro)", "nivel": 1, "descricao": "Enquanto n√£o estiver usando armadura, sua CA √© 10 + seu modificador de Destreza + seu modificador de Constitui√ß√£o." },
        { "nome": "Ataque Descuidado", "nivel": 2, "descricao": "Voc√™ pode atacar com vantagem, mas os ataques contra voc√™ tamb√©m ter√£o vantagem." },
        { "nome": "Sentido de Perigo", "nivel": 2, "descricao": "Voc√™ tem vantagem em testes de Destreza contra efeitos que pode ver, como armadilhas e magias." },
        { "nome": "Caminho Primitivo: Caminho do Berserker", "nivel": 3, "descricao": "Sua f√∫ria se torna um frenesi implac√°vel." },
        { "nome": "Caminho Primitivo: Caminho do Guerreiro Tot√™mico", "nivel": 3, "descricao": "Voc√™ comunga com esp√≠ritos animais que concedem benef√≠cios em f√∫ria." }
      ]
    },
    "bardo": {
      "nome_exibido": "Bardo",
      "descricao": "Um mestre da m√∫sica, da palavra e da magia.",
      "oficio": "Cria√ß√£o de Instrumentos Musicais",
      "dado_vida": "d8",
      "pericias_fixas": [],
      "pericias_escolha_num": 3,
      "pericias_opcoes": ["Acrobacia", "Adestrar Animais", "Arcanismo", "Atletismo", "Atua√ß√£o", "Engana√ß√£o", "Furtividade", "Hist√≥ria", "Intimida√ß√£o", "Intui√ß√£o", "Investiga√ß√£o", "Medicina", "Natureza", "Percep√ß√£o", "Persuas√£o", "Prestidigita√ß√£o", "Religi√£o", "Sobreviv√™ncia"],
      "proficiencia_armas": ["simples", "bestas de m√£o", "espadas longas", "rapieiras", "espadas curtas"],
      "equipamento_inicial": [
        { "nome": "Rapieira", "tipo": "arma_equipavel", "tipo_arma_prof": "marcial", "atributo_padrao": "des", "dado_dano": "1d8", "tipo_dano_arma": "perfurante", "propriedades_arma": ["acuidade"] },
        { "nome": "Adaga", "tipo": "arma_equipavel", "tipo_arma_prof": "simples", "atributo_padrao": "des", "dado_dano": "1d4", "tipo_dano_arma": "perfurante", "propriedades_arma": ["acuidade", "leve", "arremesso (6/18m)"] },
        { "nome": "Ala√∫de", "tipo": "instrumento_musical_foco_arcano" },
        { "nome": "Armadura de Couro", "tipo": "armadura_leve_ref", "ca_base": 11 }
      ],
      "habilidades": [
        { "nome": "Conjura√ß√£o (Bardo)", "nivel": 1, "descricao": "Voc√™ pode conjurar magias de bardo usando Carisma." },
        { "nome": "Inspira√ß√£o de Bardo", "nivel": 1, "descricao": "Voc√™ pode usar uma a√ß√£o b√¥nus para inspirar um aliado, concedendo-lhe um dado de Inspira√ß√£o (d6 no n√≠vel 1)." },
        { "nome": "Faz-Tudo (Jack of All Trades)", "nivel": 2, "descricao": "Voc√™ pode adicionar metade do seu b√¥nus de profici√™ncia a qualquer teste de habilidade que voc√™ n√£o seja proficiente." },
        { "nome": "Can√ß√£o de Descanso", "nivel": 2, "descricao": "Durante um descanso curto, voc√™ pode usar m√∫sica para ajudar seus aliados a se recuperarem melhor." },
        { "nome": "Col√©gio de Bardo: Col√©gio do Conhecimento", "nivel": 3, "descricao": "Voc√™ √© um reposit√≥rio de sabedoria e pode usar sua Inspira√ß√£o para atrapalhar inimigos." },
        { "nome": "Col√©gio de Bardo: Col√©gio da Bravura", "nivel": 3, "descricao": "Voc√™ inspira coragem no campo de batalha, ganhando profici√™ncias marciais." },
        { "nome": "Especializa√ß√£o em Per√≠cia (Bardo)", "nivel": 3, "descricao": "Escolha duas de suas profici√™ncias em per√≠cias. Seu b√¥nus de profici√™ncia √© dobrado para elas." }
      ]
    },
    "patrulheiro": {
      "nome_exibido": "Patrulheiro",
      "descricao": "Um guerreiro das selvas e fronteiras, especialista em sobreviv√™ncia e combate.",
      "oficio": "Herborismo e Cria√ß√£o de Armadilhas",
      "dado_vida": "d10",
      "pericias_fixas": [],
      "pericias_escolha_num": 3,
      "pericias_opcoes": ["Adestrar Animais", "Atletismo", "Furtividade", "Intui√ß√£o", "Investiga√ß√£o", "Natureza", "Percep√ß√£o", "Sobreviv√™ncia"],
      "proficiencia_armas": ["simples", "marciais"],
      "equipamento_inicial": [
        { "nome": "Armadura de Escamas", "tipo": "armadura_media_ref", "ca_base": 14 },
        { "nome": "Duas Espadas Curtas", "tipo": "arma_equipavel", "tipo_arma_prof": "marcial", "atributo_padrao": "des", "dado_dano": "1d6", "tipo_dano_arma": "perfurante", "propriedades_arma": ["acuidade", "leve"], "quantidade": 2 },
        { "nome": "Arco Longo", "tipo": "arma_equipavel", "tipo_arma_prof": "marcial", "atributo_padrao": "des", "dado_dano": "1d8", "tipo_dano_arma": "perfurante", "propriedades_arma": ["muni√ß√£o (45/180m)", "pesada", "duas m√£os"] },
        { "nome": "Aljava com 20 Flechas", "tipo": "municao" }
      ],
      "habilidades": [
        { "nome": "Inimigo Predileto", "nivel": 1, "descricao": "Escolha um tipo de criatura como seu inimigo predileto. Voc√™ tem vantagem em testes para rastre√°-los e recordar informa√ß√µes sobre eles." },
        { "nome": "Explorador Natural", "nivel": 1, "descricao": "Escolha um tipo de terreno favorito. Voc√™ ganha benef√≠cios enquanto nele." },
        { "nome": "Estilo de Luta (Patrulheiro): Arquearia", "nivel": 2, "descricao": "Voc√™ ganha +2 de b√¥nus nas rolagens de ataque com armas de ataque √† dist√¢ncia." },
        { "nome": "Estilo de Luta (Patrulheiro): Defesa", "nivel": 2, "descricao": "Enquanto estiver usando armadura, voc√™ ganha +1 de b√¥nus na CA." },
        { "nome": "Estilo de Luta (Patrulheiro): Duelo", "nivel": 2, "descricao": "Quando empunha uma arma corpo-a-corpo em uma s√≥ m√£o e nenhuma outra, voc√™ ganha +2 de b√¥nus nas rolagens de dano com essa arma." },
        { "nome": "Estilo de Luta (Patrulheiro): Combate com Duas Armas", "nivel": 2, "descricao": "Quando voc√™ usa duas armas, pode adicionar seu modificador de atributo ao dano do segundo ataque." },
        { "nome": "Conjura√ß√£o (Patrulheiro)", "nivel": 2, "descricao": "Voc√™ aprende a usar a ess√™ncia m√°gica da natureza para conjurar magias." },
        { "nome": "Arqu√©tipo de Patrulheiro: Ca√ßador", "nivel": 3, "descricao": "Voc√™ √© um mestre em abater amea√ßas com t√°ticas especializadas." },
        { "nome": "Arqu√©tipo de Patrulheiro: Mestre das Bestas", "nivel": 3, "descricao": "Voc√™ forma um la√ßo com um companheiro animal que luta ao seu lado." }
      ]
    }
  }

